<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucia</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lupeipei.github.io/"/>
  <updated>2023-03-11T12:39:51.548Z</updated>
  <id>http://lupeipei.github.io/</id>
  
  <author>
    <name>Lucia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录第一次装机</title>
    <link href="http://lupeipei.github.io/posts/my-first-time-assembling-a-desktop-pc/"/>
    <id>http://lupeipei.github.io/posts/my-first-time-assembling-a-desktop-pc/</id>
    <published>2023-03-11T12:30:50.000Z</published>
    <updated>2023-03-11T12:39:51.548Z</updated>
    
    <content type="html"><![CDATA[<p>终于把Win11装好了. 来打个卡记录下.</p><span id="more"></span> <p>去年心血来潮, 想要体验下装机, 试试3D打印, 然后随口跟 Ran 提了下, 再然后, 就莫名其妙入坑了……..</p><p>纯小白, 从买零件到装机, 埋线, 再到安装Win11, 历时小半年…..</p><p>呃, 花了这么久的时间, 是因为装机后, 一直没装系统, 就像 Ran 调侃的, 你的金属大师都吃灰了好几个月了吧?</p><p>呃, 惭愧 [捂脸]</p><p>把装系统的事速度安排上.</p><p>好了, 不多唠了, 简单记录下装机和装系统的过程中的一些问题.</p><h4 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h4><p>先来晒下零件:</p><table><thead><tr><th>零件</th><th>产品</th></tr></thead><tbody><tr><td><strong>CPU</strong></td><td>AMD R5 5600X</td></tr><tr><td><strong>主板</strong></td><td>华硕 TUF B550M-Plus WIFI II</td></tr><tr><td><strong>内存</strong></td><td>威刚 D45 DDR4 16Gx2</td></tr><tr><td><strong>电源</strong></td><td>NZXT C750</td></tr><tr><td><strong>散热</strong></td><td>3 x 利民 TL-C12-W 12cm white + 利民 AXP90-X47 white</td></tr><tr><td><strong>机箱</strong></td><td>JOSNSBO D30</td></tr><tr><td><strong>SSD</strong></td><td>TiPro 7000 1T  + TiPlus 5000 1T</td></tr><tr><td><strong>显卡</strong></td><td>影驰 RTX 3060Ti G6X 金属大师</td></tr></tbody></table><p>基本都是Ran的推荐, 很满意, 谢谢Ran!!!</p><p>PS. 有一个既懂装机又爱操心显卡吃灰的同事, 真的很幸运! : P</p><p>这里稍稍提下, 如果机箱选了D30, 同时计划后续要安装机械硬盘, 购买显卡时, 需要考虑下长度. 不然有可能显卡买回来后安顿好, 发现硬盘已经塞不进机箱了…</p><p>所有零件买好后, 装机也很简单, 如果你跟我一样, 都是小白, 可以参考 B站 up主硬件茶谈出的保姆级教程[这个也是Ran推荐的 ^_^].</p><p>PPS. D30 机箱真的好好看啊!!</p><h4 id="装机-1"><a href="#装机-1" class="headerlink" title="装机"></a>装机</h4><h5 id="使用Mac做一个Win11的-USB启动盘"><a href="#使用Mac做一个Win11的-USB启动盘" class="headerlink" title="使用Mac做一个Win11的 USB启动盘"></a>使用Mac做一个Win11的 USB启动盘</h5><p>这里以Win11为例. 准备好U盘, 去<a href="https://www.microsoft.com/en-us/software-download/windows11">官网</a>下载 ISO 文件. </p><p>参考这篇<a href="https://www.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/">Build a Bootable ISO From Your Mac’s Terminal</a>, 5 步完成.</p><ol><li><p>终端输入  <code>diskutil list</code> , 找到插入的那个USB (带有 external disk), 假定是 <code>/dev/disk2</code></p></li><li><p>终端输入 <code>diskutil eraseDisk MS-DOS &quot;WIN11&quot; GPT /dev/disk2</code>, 格式化USB</p></li><li><p>终端输入  <code>hdiutil mount ~/Downloads/Win11_22H2_Chinese_Simplified_x64v1.iso</code>,  挂载Win11 的IOS, 这里 <code>Win11_22H2_Chinese_Simplified_x64v1.iso</code> 就是下载的ISO文件名.</p></li><li><p>终端输入<code>rsync -vha --exclude=sources/install.wim /Volumes/CCCOMA_X64FRE_ZH-CN_DV9/* /Volumes/WIN11</code> , 这步把安装的镜像文件 Copy 到你的USB中, 除了 <code>install.wim</code> 文件(下一步会处理), 其他都Copy 过去. 其中<code>/Volumes/CCCOMA_X64FRE_ZH-CN_DV9/*</code>  是第3步生成的disk image 文件地址.</p></li><li><p>下载 <code>wimlib</code>, 把第4步漏掉的 wim文件分成两份 Copy 过去. [中文简体的 WIN11_22H2 里面的install.wim 大概是4.5G, 可以通过命令行查看文件大小: <code>du -sh /Volumes/CCCOMA_X64FRE_ZH-CN_DV9/sources/install.wim</code> ]</p><p>终端输入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install wimlib</span><br></pre></td></tr></table></figure><p>安装完成后, 通过wimlib, 将WIM文件拆分成两个小于4G的文件Copy 到USB:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wimlib-imagex split /Volumes/CCCOMA_X64FRE_ZH-CN_DV9/sources/install.wim /Volumes/WIN11/sources/install.swm 3800</span><br></pre></td></tr></table></figure></li></ol><p>OK, 搞定! 可以装Win11啦~ </p><h5 id="有关WIN11安装过程中跳过联网"><a href="#有关WIN11安装过程中跳过联网" class="headerlink" title="有关WIN11安装过程中跳过联网"></a>有关WIN11安装过程中跳过联网</h5><p>在安装系统的过程中, 会有一步, 要求连接网络. 参考 <a href="https://www.53xt.com/jiaocheng/7998.html">win11怎么跳过联网</a>, 可以使用命令行跳过.</p><p>具体步骤:</p><blockquote><ul><li><p>按 Shift + F10 , 弹出 命令提示符 cmd 窗口, 输入 <code>OOBEBYPASSNRO</code>  回车.</p></li><li><p>随后电脑会重启, 然后再次回到这个界面时, 会多出 [我没有Internet连接] 的选项, 选择即可.</p></li></ul></blockquote><p>最后, 晒下我的D30~</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images1.jpeg"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>Ran</p><p><a href="https://www.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/">Build a Bootable ISO From Your Mac’s Terminal</a></p><p><a href="https://www.53xt.com/jiaocheng/7998.html">win11怎么跳过联网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于把Win11装好了. 来打个卡记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>读《美丽新世界》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-brave-new-world/"/>
    <id>http://lupeipei.github.io/posts/notes-of-brave-new-world/</id>
    <published>2023-02-24T13:41:40.000Z</published>
    <updated>2023-02-28T06:44:01.984Z</updated>
    
    <content type="html"><![CDATA[<p>2022年读了一些书, 但是偷懒没做笔记, 来填坑。</p><p>先从阿道斯·赫胥黎（Aldous Huxley) 这本经典小说开始吧。</p><span id="more"></span><p>这本书饱受赞誉,  被认为是赫胥黎最著名的作品。</p><p>书名为《brave new world》, 译为《美丽新世界》, 也译做《美妙的新世界》。 书名取自莎士比亚的戏剧《暴风雨》第五幕的一句台词。 国王普洛斯彼罗有个女儿, 叫做米兰达，米兰达从小生长在荒岛上，没有见过人类。 在一次暴风雨之后, 米兰达见到了因海难而漂流到海岛上的人, 说出了那句著名的台词：“O, wonder! How many goodly creatures are there here! How beauteous mankind is! O <strong>brave new world</strong>, That has such people in’t!” </p><p>不过作者在书中构建的这个新世界跟米兰达眼中的新世界, 应该处在不同的星系: P</p><p>故事发生在福帝纪元632年, 相当于公元2540年。[注: 书中把美国汽车大王福特(Herry Ford)当作上帝，把他生产的T型车的1908年定作纪元元年。 ]</p><p>这个时代胎生已经被取消, 人们通过人工培育试管出生, 所有人在尚未出生时, 就已经被设置好了条件, 从胚胎时期就预设好了种姓。这里简单插播下新世界的种姓制度。</p><p>新世界里面有五个主要的种姓, 分别是阿尔法、贝塔、伽玛、德尔塔、伊普西龙, 对应希腊字母表的头五个字母 α、β、γ、δ和ε。 每个种姓又有加减组合, 所以一共有10种。 其中阿尔法、贝塔属于高种姓, 贝塔减是高种姓里的最低级，大概做基层管理工作。伽玛、德尔塔、伊普西龙都是低种姓，从事体力劳动。</p><p>除了预设好的种姓, 每个婴儿出生后, 都会经历上万次重复的睡眠教育和条件反射刺激, 如此, 当一个婴儿长大后, 会自然长成条件设置下的产物, 处在婴儿般幸福的状态, 喜欢他们无法逃避的社会命运。</p><p>同时, 为了稳定, 不让人们产生强烈的情绪波动,  新世界里, 男女之间没有感情, 稳定单一的关系被认为是不正常的, 人们没有父母, 没有妻儿, 没有情人, 性交不受限制, 感官电影, 游戏无限供应。 人们想要什么就有什么，同时条件设置使得人们绝不会要他们得不到的东西。即使偶尔出了问题, 比如有人对社会体系提出质疑甚至反抗, 也会有唆麻, 有唆麻, 无烦恼, 带你斩断思考, 进入美好世界。 [当然, 不出问题的时候, 唆麻也是定量供应的。]</p><p>这所有的一切, 保证了整个社会的稳定。</p><p> 不过, 在新世界之外, 统治者们还留有一块保留地, 那里的人们过着印第安人原始而疯狂的日子。 这块保留地如同一个异世界, 与新世界保持着隔离状态。 只有某些高种姓的人, 才享有去保留地度假的权利。</p><p>育种中心的主任便是其中一个。</p><p>二十多年前, 育种中心主任带着他的女友琳达从新世界来到保留地度假,  琳达因为意外未能离开, 留在了保留地马尔佩斯, 随后发现自己怀有身孕, 在保留地生下了她和主任的儿子, 取名约翰。</p><p>约翰因其出身, 从小受到同伴排挤, 内心孤独, 稍年长时, 琳达教他识字, 一次偶然的机会, 约翰读到了莎士比亚全集, 思想上开始受到莎翁作品的影响, 同时跟保留地的米季马学习做陶器, 做弓, 掌握生存的技能, 在马尔佩斯逐渐长大成人。</p><p>与此同时, 育种中心的睡眠教育专家伯纳·马克思因育种失误, 身高比正常阿尔法种姓的人要低, 导致其内心敏感, 对现有体系抱有反抗情绪, 于是伯纳带着美丽灵气的护士列宁娜一起前往保留地, 在保留地遇到了约翰和琳达。 约翰对列宁娜一见钟情, 而伯纳以”研究”为名义, 将约翰和琳达带回了新世界。</p><p>来到新世界后, 约翰作为保留地的野蛮人, 受到众人追捧, 随后跟伯纳的好友赫姆霍尔兹成了至交。而列宁娜也对约翰产生好感, 但约翰面对列宁娜的主动献身, 深感失望, 心中对美好爱情的幻想破灭, 痛斥列宁娜为“娼妇”。</p><p>另一边, 回到新世界后的琳达, 因为终日服用大剂量的唆麻来逃避痛苦, 缩短了寿命, 早早离世。 </p><p>约翰在母亲琳达离世当天来到医院, 离开医院时, 偶遇工作人员正在发放唆麻, 约翰内心愤恨, 把唆麻毒品扔掉, 赫姆霍尔兹和伯纳得知后赶来, 随后赫姆霍尔兹加入扔唆麻的行动, 这一举动造成人群恐慌,  场面一度混乱。最终三人被赶来的警察带到了总统办公室, 在与总统的一番交流后, 伯纳和赫姆霍尔兹被流放到小岛, 而约翰则选择了隐居。</p><p>隐居后的约翰并没有过上平静的生活, 频繁遭遇记者抓拍, 采访, 被众人围观, 最终约翰选择在忏悔中自杀。</p><p>故事到此也就结束了。</p><p>是个悲伤的故事。</p><p>作者在序言中提到, 如果重写这本小说, 他会给野蛮人第三条路:</p><p>一个”清醒”的社会 -  这个社会由某些从“美丽新世界”流放和逃亡出来的人组成,  这是一个由追求清醒的人自由合作组成的一个社会,  地点在保留地附近。</p><p>如果真的有这个选择, 约翰会在这个世界里遇到心爱的姑娘, 拥有一份他心中那天长地久般的爱情吧。</p><p>毕竟这个世界, 应该比米兰达眼中的那个新世界更美好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2022年读了一些书, 但是偷懒没做笔记, 来填坑。&lt;/p&gt;
&lt;p&gt;先从阿道斯·赫胥黎（Aldous Huxley) 这本经典小说开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Forever Young</title>
    <link href="http://lupeipei.github.io/posts/forever-young/"/>
    <id>http://lupeipei.github.io/posts/forever-young/</id>
    <published>2023-02-15T14:25:58.000Z</published>
    <updated>2023-02-15T14:36:22.081Z</updated>
    
    <content type="html"><![CDATA[<p>Bob Dylan 有首歌, 歌名《Forever Young》. 今天重听了 John Roberts 法官的那篇<a href="https://www.youtube.com/watch?v=pqzbEGA3x2I">Speech</a>. John 在结束演讲之前, 诵读了 Bob 这首歌的歌词, 或者更贴切点说, 诵读了这首”诗”.</p><p>初时懵懂无知, 现在听来觉得很美, 分享下.</p><span id="more"></span><p>以下为整首内容:</p><p>May God bless you and keep you always<br>May your wishes all come true<br>May you always do for others<br>And let others do for you<br>May you build a ladder to the stars<br>And climb on every rung<br>And may you stay forever young</p><p>May you grow up to be righteous<br>May you grow up to be true<br>May you always know the truth<br>And see the lights surrounding you<br>May you always be courageous<br>Stand upright and be strong<br>And may you stay forever young</p><p>May your hands always be busy<br>May your feet always be swift<br>May you have a strong foundation<br>When the winds of changes shift<br>May your heart always be joyful<br>May your song always be sung<br>And may you stay forever young</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bob Dylan 有首歌, 歌名《Forever Young》. 今天重听了 John Roberts 法官的那篇&lt;a href=&quot;https://www.youtube.com/watch?v=pqzbEGA3x2I&quot;&gt;Speech&lt;/a&gt;. John 在结束演讲之前, 诵读了 Bob 这首歌的歌词, 或者更贴切点说, 诵读了这首”诗”.&lt;/p&gt;
&lt;p&gt;初时懵懂无知, 现在听来觉得很美, 分享下.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
      <category term="Poem" scheme="http://lupeipei.github.io/tags/Poem/"/>
    
  </entry>
  
  <entry>
    <title>update json data in postgreSQL</title>
    <link href="http://lupeipei.github.io/posts/update-json-data-in-postgreSQL/"/>
    <id>http://lupeipei.github.io/posts/update-json-data-in-postgreSQL/</id>
    <published>2022-12-16T13:43:24.000Z</published>
    <updated>2022-12-16T13:48:45.126Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇到的一个问题, 需要更新数据表里面的一个JSON字段, 最后的解决方法有点小巧妙, 整个求解的过程也蛮有意思, 记录下.</p><span id="more"></span> <h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>假定现有一张表 orders, orders 中有 一个 double 类型的字段 amount 和 一个 JSON 类型的 meta, 现在需要更新orders中的amount字段(amount = amount * 2) , 同时将更新前的 amount 旧值存在 meta 中.</p><p>假定更新前 orders 表的数据如下:</p><table><thead><tr><th><strong>id</strong></th><th><strong>amount</strong></th><th><strong>meta</strong></th></tr></thead><tbody><tr><td>1</td><td>10</td><td>{“type”=&gt; “market_order”, “user_id”=&gt; “9”}</td></tr></tbody></table><p>预期更新后的数据:</p><table><thead><tr><th><strong>id</strong></th><th><strong>amount</strong></th><th><strong>meta</strong></th></tr></thead><tbody><tr><td>1</td><td>20</td><td>{ “type”=&gt; “market_order”, “user_id”=&gt;  “9”, “changed_attributes”: { “amount” =&gt; “10”} }</td></tr></tbody></table><p>postgresql version: 14.4</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>初看并不复杂, 通常情况下, 给JSON字段插入新的Key-value 这么来:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE orders</span><br><span class="line"><span class="keyword">SET</span> </span><br><span class="line">amount <span class="operator">=</span> amount <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">meta <span class="operator">=</span> meta <span class="operator">||</span> <span class="string">&#x27;&#123;&quot;changed_attributes&quot;:&#123;&quot;amount&quot;:&quot;10&quot;&#125;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但是这里 amount 的旧值不是常量, 需要改成 amount 字段的值. 如果直接把10换成amount 执行, 最后存在 meta 中的就是amount 这个字符串, 而不是 amount 的值10.</p><p>那该怎么办?</p><p>当时Google了半天也没有找到答案, 后面索性厚着脸皮请教了Data Team 的同事, 同事给到的解决方法有些意外, 巧用 || 字符串拼接符号即可.</p><p>把 10 换成 amount, 用 || 拼接起来.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">meta <span class="operator">=</span> meta <span class="operator">||</span> <span class="string">&#x27;&#123;&quot;changed_attributes&quot;:&#123;&quot;amount&quot;:&quot;&#x27;</span><span class="operator">||</span>amount<span class="operator">||</span><span class="string">&#x27;&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>拆解下看得更清楚:</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;changed_attributes&quot;</span>:&#123;<span class="string">&quot;amount&quot;</span>:<span class="string">&quot; || </span></span><br><span class="line">amount <span class="string">||</span></span><br><span class="line"><span class="string">&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>但是运行的时候,会报错: the input string ended unexpectedly. 因为符号’的原因,  程序只解析 <code>&#123;&quot;changed_attributes&quot;:&#123;&quot;amount&quot;: &quot;</code> 剩下的就不会解析. 我们可以用类型转换符包起来.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">meta <span class="operator">=</span> meta <span class="operator">||</span> (<span class="string">&#x27;&#123;&quot;changed_attributes&quot;:&#123;&quot;amount&quot;:&quot;&#x27;</span><span class="operator">||</span>amount<span class="operator">||</span><span class="string">&#x27;&quot;&#125;&#125;&#x27;</span>)::jsonb</span><br></pre></td></tr></table></figure><p>最后的脚本:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE orders</span><br><span class="line"><span class="keyword">SET</span> </span><br><span class="line">amount <span class="operator">=</span> amount <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">meta <span class="operator">=</span> meta <span class="operator">||</span> (<span class="string">&#x27;&#123;&quot;changed_attributes&quot;:&#123;&quot;amount&quot;:&quot;&#x27;</span><span class="operator">||</span>amount<span class="operator">||</span><span class="string">&#x27;&quot;&#125;&#125;&#x27;</span>)::jsonb;</span><br></pre></td></tr></table></figure><p>再次执行, OK!</p><p>[原来答案并不复杂, 把问题复杂化反而是给自己挖坑, 换个思路看问题, 其实可以很简单: P]</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.databasestar.com/postgresql-json/">JSON in PostgreSQL: The Ultimate Guide</a></p><p>a nice teammate from Data Team [感谢大佬指点!] </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中遇到的一个问题, 需要更新数据表里面的一个JSON字段, 最后的解决方法有点小巧妙, 整个求解的过程也蛮有意思, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="postgreSQL" scheme="http://lupeipei.github.io/tags/postgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Conditionals</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-if-conditionals/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-if-conditionals/</id>
    <published>2022-10-30T14:14:03.000Z</published>
    <updated>2022-10-30T14:21:04.758Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们来看看 Vim中的 conditionals.</p><p>Vim 中的条件式只有 <code>if</code>, 没有 <code>unless</code> (Ruby 有 <code>unless</code>).</p><span id="more"></span> <p>先看个简单的例子:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:if</span> <span class="number">1</span></span><br><span class="line">:  echom <span class="string">&quot;ONE&quot;</span></span><br><span class="line"><span class="symbol">:endif</span></span><br></pre></td></tr></table></figure><p>输出: “ONE”, 符合预期.</p><p>这里如果我们不想在command 模式下输入这么多行, 可以用 <code>|</code> (管道pipe) 来连接每一行:</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">if</span> <span class="number">1</span> | <span class="type">echom</span> <span class="string">&quot;ONE&quot;</span> | <span class="type">endif</span></span><br></pre></td></tr></table></figure><p>从这个简单的例子, 我们可以看出对于 非 0 的数字 1, Vim 认为是  truthy.</p><p>反之:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:if</span> 0</span><br><span class="line">:  echom <span class="string">&quot;ZERO&quot;</span></span><br><span class="line"><span class="symbol">:endif</span></span><br></pre></td></tr></table></figure><p>此时什么都不输出. 表达式为 0 时,为 falsy.</p><p>再看个字符串的例子:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:if</span> <span class="string">&quot;kitty&quot;</span></span><br><span class="line">:    echom <span class="string">&quot;cute!&quot;</span></span><br><span class="line"><span class="symbol">:endif</span></span><br></pre></td></tr></table></figure><p>此时仍然是什么也没有输出, 所以  Vim 是默认将字符串处理成 falsy?</p><p>换个例子:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:if</span> <span class="string">&quot;01kitty&quot;</span></span><br><span class="line">:    echom <span class="string">&quot;cute!&quot;</span></span><br><span class="line"><span class="symbol">:endif</span></span><br></pre></td></tr></table></figure><p>此时输出: “cute!”. what? (此处适合配个黑人问号脸….)</p><p>为了弄懂怎么回事,  我们把 “kitty” 和 “01kitty” 拎出来跑跑:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:echom</span> <span class="string">&quot;kitty&quot;</span> + 0</span><br><span class="line"><span class="symbol">:echo</span> <span class="string">&quot;01kitty&quot;</span> + 0</span><br><span class="line"><span class="symbol">:echo</span> <span class="string">&quot;kitty01&quot;</span> + 0</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>从输出的结果可以看出,  Vim 把字符串转化成整数时, 如果字符串是以数字开头的,会转化成开头的数字, 否则就是0.</p><p>所以上面两个 kitty 例子的运行结果, 也就合理了. “kitty” =&gt; 0 =&gt; falsy, “01kitty” =&gt; 1 =&gt; truthy. 破案.</p><p>我们再来看看比较表达式:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:if</span> <span class="number">10</span> &gt; <span class="number">1</span></span><br><span class="line">:    echom <span class="string">&quot;10 is bigger than 1&quot;</span></span><br><span class="line"><span class="symbol">:endif</span></span><br></pre></td></tr></table></figure><p>输出: “10 is bigger than 1”,  这结果没啥特别的, 很正常.</p><p>再来看个字符串的对比:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;cat&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is cat&quot;</span></span><br><span class="line">:<span class="keyword">elseif</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;dog&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is dog&quot;</span></span><br><span class="line">:<span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>输出: “cat is cat”. 嗯, 没毛病.</p><p>来看看大小写的情况:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;CAT&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is CAT&quot;</span></span><br><span class="line">:<span class="keyword">elseif</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;cat&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is cat&quot;</span></span><br><span class="line">:<span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>输出: “cat is cat”. 看来 Vim 是 case sensitive ?</p><p>NO.</p><p>我们先来看看 setting 是不是 case sensitive 的.</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> ignorecase?</span><br></pre></td></tr></table></figure><p>输出: noignorecase, 说明option ignorecase 的值是noignorecase, 不忽略大小写, 也就是case sensitive.</p><p>我们修改下:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> ignorecase</span><br><span class="line">:<span class="builtin-name">set</span> ignorecase?</span><br></pre></td></tr></table></figure><p>此时我们将配置修改为了 ignorecase, case insensitive.</p><p>(还记得option 的配置吗? 当option 是二元值时, 使用 <code>set &#123;option&#125;</code>, <code>set no&#123;option&#125;</code> 来enable/disable option)</p><p>我们再来跑上面的例子:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;CAT&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is CAT&quot;</span></span><br><span class="line">:<span class="keyword">elseif</span> <span class="string">&quot;cat&quot;</span> == <span class="string">&quot;cat&quot;</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">&quot;cat is cat&quot;</span></span><br><span class="line">:<span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>输出: “cat is CAT”.</p><p>上面的例子教会了我们什么呢? 作者说我们应该永远也不要相信  <code>==</code> , 至少它不应该出现在你的Plugin 中(永远预设用户的配置多变).</p><p>嗯, 那咱得换个比较运算符.</p><p>估计你也猜到了, Vim 早已准备好了对应的操作符.</p><p>来认识下 <code>==?</code>(忽略大小写) &amp;&amp; <code>==#</code>(不忽略大小写)</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> noignorecase</span><br><span class="line">:if <span class="comment">&quot;cat&quot;</span> <span class="comment">==?</span> <span class="comment">&quot;CAT&quot;</span></span><br><span class="line">:    echom <span class="comment">&quot;cat is CAT&quot;</span></span><br><span class="line">:elseif <span class="comment">&quot;cat&quot;</span> <span class="comment">==?</span> <span class="comment">&quot;cat&quot;</span></span><br><span class="line">:    echom <span class="comment">&quot;cat is cat&quot;</span></span><br><span class="line">:endif</span><br></pre></td></tr></table></figure><p>输出: “cat is CAT”</p><p>虽然我们设置了 noignorecase, 不忽略大小写, 但是if 中 使用了 <code>==?</code> , 表示比较时, 忽略大小写, 所以第一个表达式的结果为  true, 输出 “cat is CAT”.</p><p>同样:</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> ignorecase</span><br><span class="line">:if <span class="comment">&quot;cat&quot;</span> <span class="comment">==#</span> <span class="comment">&quot;CAT&quot;</span></span><br><span class="line">:    echom <span class="comment">&quot;cat is CAT&quot;</span></span><br><span class="line">:elseif <span class="comment">&quot;cat&quot;</span> <span class="comment">==#</span> <span class="comment">&quot;cat&quot;</span></span><br><span class="line">:    echom <span class="comment">&quot;cat is cat&quot;</span></span><br><span class="line">:endif</span><br></pre></td></tr></table></figure><p>这时输出: “cat is cat”.</p><p>对于比较运算符, 可以查看官方文档了解更多:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:h</span> expr4</span><br></pre></td></tr></table></figure><p>好,  If 这块差不多了, 是不是超简单? 收工收工. 下一节聊 function~.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节我们来看看 Vim中的 conditionals.&lt;/p&gt;
&lt;p&gt;Vim 中的条件式只有 &lt;code&gt;if&lt;/code&gt;, 没有 &lt;code&gt;unless&lt;/code&gt; (Ruby 有 &lt;code&gt;unless&lt;/code&gt;).&lt;/p&gt;
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>读《托斯卡纳艳阳下》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-under-the-tuscan-sun/"/>
    <id>http://lupeipei.github.io/posts/notes-of-under-the-tuscan-sun/</id>
    <published>2022-10-18T06:46:47.000Z</published>
    <updated>2022-10-18T06:59:59.827Z</updated>
    
    <content type="html"><![CDATA[<p>生活是如此的美好.</p><span id="more"></span><p>本书讲述了作者 Frances Mayes 在意大利旅游期间, 在当地买了一栋房, 随后开启了在托斯卡纳惬意而自在的田园生活. 修葺房屋, 种植橄榄,  邀请朋友来家中作客, 闲时驱车去周边城镇采购葡萄酒, 观赏沿途的田园风光…..</p><p>两个人, 一座古老的城镇, 一栋房子, 一种新的生活.</p><p>天堂般的日子.</p><p>Frances 买下的这栋房子, 叫巴摩梭罗(bramarsolo). 这是个美丽的名字. </p><p>为什么这是个美丽的名字?</p><p>因为 bramarsolo 由 bramare(渴望) 和 solo(阳光) 组成, 意为渴望阳光. 是不是很美?</p><p>这里确实很阳光.</p><p>整栋房子坐落在1500英尺的山坡上, 早上的第一缕阳光会打在露台的门上, 照进书房.  窗外, 杜鹃伏在菩提树上鸣叫着, 入耳的还有其他鸟儿的阵阵鸣叫声, 此刻你从睡梦中被唤醒,  伸伸懒腰, 新的一天开始了.  起床后, 你将窗户敞开, 蝴蝶, 蜜蜂, 任何小生物, 随时可以从窗户进进出出, 你感受着与户外相连的喜悦.  收拾收拾后, 你走出门. 房子前面的小道上种了玫瑰.薰衣草, 茉莉花正沿着铁扶手攀爬, 草坪上的草已经长得很厚,  如果你愿意, 可以光着脚走在花园里, 采摘玫瑰或者一束薰衣草,  插在书房的花瓶里, 或者只是走在小道上,  等风吹过时, 任由各种香味层层扑鼻而来, 深呼吸, 来一场香味理疗.</p><p>出了小道, 不远处, 是梯田. 梯田上长满高大的橄榄树,  你沿着梯田散步, 随手清理着梯田中的杂草, 想着, 等到3月时, 这些高大的橄榄树会次第开花结果. 待到圣诞前期, 太阳照出第一道光芒时, 就要开始采收橄榄, 那时枝桠上垂满了果实,  果实上挂着沉甸甸的露珠, 山谷中漂浮着浓浓的雾气,  又是新一轮的收获季, 你将成熟的橄榄摘下, 放进大袋子, 等到采摘结束时, 邻居们会开来拖拉机, 把成袋成袋的橄榄送去磨坊加工, 来年就可以美美地享用自家树上产的新鲜橄榄油. 哇, 想想就很美好.</p><p>从梯田回来, 享用完早餐, 你去附近的市集逛逛, 采购食材, 去玛丽亚的蔬菜水果店, 怎么样? 买些无花果, 还有她早晨刚摘下的紫葡萄, 堆成金字塔的红辣椒,  或者去托斯卡纳的周边逛逛, 买些当地人自家酿的葡萄酒, 填充自己的酿酒室, 走到饥肠辘辘时, 便找一家当地的餐厅饱食一顿.</p><p>用完午餐后, 你还可以睡个长长的午觉. 午后镇子里少有人走动, 周边上着百叶窗的房屋此时静悄悄的, 这里的白天有三个小时长的午睡, 小镇平静而安宁, 如梦境般.</p><p>待到晚饭时分, 在户外的餐桌上摆上食物, 花上两个小时,  慢慢享用着晚饭, 养足精神后, 沿着山谷边的花圃, 散步到镇上, 消消食, 然后选择一家咖啡店消磨时光.</p><p>夜里, 从小道走回家中,  此时山中比较凉, 夜幕广大而宁静,  运气好的话, 还会遇到流星雨. </p><p>Frances 说, 托斯卡纳, 天堂般的生活,  如果有来生, 我要回到这里.</p><p>我读完后, 也很想说, 如果可以, 请把我瞬间移动到托斯卡纳吧. 感受采摘橄榄, 送去磨坊榨橄榄油的快乐. 用自己的双手去劳作, 去种上无花果树和玫瑰, 去采摘秋末甘甜的果实, 去重获对季节和时间的敏感. 实实在在, 敞亮鲜活. 顺便再闻一闻小道上飘来的阵阵花香, 赞一声: What a wonderful life!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活是如此的美好.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>天凉好个秋</title>
    <link href="http://lupeipei.github.io/posts/lying-flat/"/>
    <id>http://lupeipei.github.io/posts/lying-flat/</id>
    <published>2022-09-14T01:57:44.000Z</published>
    <updated>2022-09-14T05:57:00.192Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次Blog更新, 已4月有余.</p><span id="more"></span> <p>妥妥摆烂的节奏.</p><p>像是给自己放了双倍的暑假一样.</p><p>这段时间做了什么呢?</p><p>种花种菜. 培植豆芽, 刷剧闲逛…..</p><p>兴致冲冲去网上买青椒, 小番茄, 生菜, 香芹之类的嫩苗, 栽种, 浇水, 幻想过不了多久, 我的小阳台就会硕果累累. 但青椒仅开了几次花, 从未结果, 而小番茄, 生菜基本全军覆没, 香芹还剩一两棵在苦苦撑着.</p><p>不过开心的是, 买到了一棵很不错的柠檬树, 很健康, 长势可喜, 期待明年枝头能挂上小小的柠檬.</p><p>再说培植豆芽, 这个真的蛮奇特的.</p><p>绿豆芽培植很简单, 基本4~5天就能发好. 往往第3/4天时, 猛涨, 掀开纱布, 看到窜出来大批大批的豆芽, 冒着尖尖, 心喜, 真心好看.</p><p>培植花生芽就不那么顺利了.</p><p>培植花生芽时, 正值酷暑, 避光后, 容易发霉, 后来我索性改成了种花生, 发芽后, 都扔进花盆里. 好在最近花生苗开花了, 也算是个意外收获.</p><p>另一个意外收获则是紫薯, 买来的紫薯因保存不当, 发了芽, 长出很多深紫色的嫩芽,  随手扔土里, 不定时浇些水, 它们便肆意生长, 藤叶攀爬着, 占了大半个窗户, 现在就坐等着秋末的时候收割.</p><p>不得不说, 有心栽种的大部分都挂了, 无心栽种的倒个个长得贼壮实.</p><p>这样看, 似乎这段时间过得还不错.</p><p>但好像并不是.</p><p>这几个月来, 感觉我基本开启了躺平模式.</p><p>刚进新公司时, 学了一些 Lua, Elixir 的知识, 后面没用上, 也基本全忘了.</p><p>之前定下的计划, 想要做的事情, 也全部搁浅.</p><p>日常上班, 下班后, 就出门溜达溜达, 回来刷刷剧. 没事就倒腾倒腾绿植.</p><p>但是看到他人很努力去学习新的知识, 去提升自己时, 又会不自觉陷入了焦虑, 告诫自己不能躺平, 但是内心想要躺平, 结果弄得很拧巴.</p><p>归根究底, 还是没有那么的喜欢.</p><p>若真的喜欢, 他人眼中的”努力勤奋”, 在当事人看来, 不过是在”玩”而已. 不是吗?</p><p>可谁又不喜欢进步呢?</p><p>自己学会了从前不会的技能, 理解了之前不能理解的事物, 完成了曾经以为不可能完成的事情,  这种喜悦, 这种快乐, 远远不是刷刷短视频逛吃逛吃之类的活动所能比的.</p><p>这样想来, 进步确实是刚需.而且是永恒的刚需.</p><p>嗯, 得换下模式, 毕竟一直躺平的话, 容易退化.</p><p>假期暂时结束, 带上小铲子, 填坑填坑.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上次Blog更新, 已4月有余.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Install Command Line Developer Tools stuck on finding software</title>
    <link href="http://lupeipei.github.io/posts/install-command-line-developer-tools-stuck-in-finding-software/"/>
    <id>http://lupeipei.github.io/posts/install-command-line-developer-tools-stuck-in-finding-software/</id>
    <published>2022-05-12T00:57:39.000Z</published>
    <updated>2022-05-12T01:02:42.459Z</updated>
    
    <content type="html"><![CDATA[<p>还是记录下,  虽然大概率是不会遇到这种情况的.</p><span id="more"></span> <h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>拿到新机Mac, 第一次安装Homebrew 时, 一直卡在了 installing Command Line Developer Tools. 于是改用:</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure><p>安装时, 一直卡在了 finding Software.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220512082710.png"></p><p>环境:</p><p>MacOS Big Sur 11.6</p><p>xcode-select version 2384</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>改用手动安装.</p><p>去官方 <a href="https://developer.apple.com/support/xcode/">support Xcode</a> 查看对应 OS 需要安装的 Xcode 和 Command line tools for Xcode.</p><p>以MacOS Big Sur 11.6为例, Xcode 11 ~ 13.2 都可以. 但如果选择安装 version 11/12 后, 在最后会弹出报错 OS version too new. 建议直接安装可适配的最新版本. </p><p>这里选择 Xcode 13.2.1, 对应的下载 Command line tools for Xcode 13.2.</p><p>手动安装后, 重新 install homebrew, OK.</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>现在来看, 这个问题很简单, 但是当时我在这里卡了好几个小时. </p><p>我去 App Store 下载 Xcode, 提示OS 需要升级到Monterey 12. 于是改去升级系统, 但是升级 OS 时, 一直卡在 finding update. 然后Google了下, 把相关的 .plist 文件删除, 重启电脑. 再次打开. OS升级依然卡在 finding update….</p><p>于是陷入了一个chain里, 为了解决A, 需要解决B, 为了解决B, 需要解决C, 然后卡在C….</p><p>后面觉得不对,  为什么一定要升级系统? 为了安装 Xcode.那 Xcode一定要从 App Store 安装?  不必, 去官方下载页面找适配的就行.</p><p>换个思路容易多了.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://developer.apple.com/support/xcode/">support Xcode</a></p><p><a href="https://www.reddit.com/r/MacOSBeta/comments/hgub53/install_command_line_developer_tools_is_stuck_on/">“Install Command Line Developer Tools” is stuck on “Finding software”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是记录下,  虽然大概率是不会遇到这种情况的.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Mac" scheme="http://lupeipei.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>deoplete failed to init in Vim8</title>
    <link href="http://lupeipei.github.io/posts/deoplete-fail-to-init-in-vim8/"/>
    <id>http://lupeipei.github.io/posts/deoplete-fail-to-init-in-vim8/</id>
    <published>2022-05-07T07:59:59.000Z</published>
    <updated>2022-05-07T08:02:36.054Z</updated>
    
    <content type="html"><![CDATA[<p>踩了两次坑, 记录下.</p><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>执行<code>brew upgrade </code> 后, 终端打开 <code>.vimrc</code> 文件一直报错:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220507151533.png"></p><p>显示 [vim-hug-neovim-rpc] requires one of  <code>:pythonx import [pynvm|neovim]</code>.</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><a href="https://github.com/roxma/vim-hug-neovim-rpc">vim-hug-neovim-rpc</a> 的 Issues  <a href="https://github.com/roxma/vim-hug-neovim-rpc/issues/47">Error Every time I load in vim8 (not neovim)</a> 提到了这个.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220507152627.png"></p><p>Vim 跑了下<code>:pythonx import sys; print(sys.path)</code>,  发现Vim里面用的Python是3.10. </p><p>而我本地的 python3 版本却是 3.7.9.  猜测<code>brew upgrade</code> 后,  relink了3.7.9?</p><p>参考上面的解法, 终端执行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/opt/python@3.10/bin/pip3 install pynvim</span><br></pre></td></tr></table></figure><p>再次打开<code>.vimrc</code>, 无报错. OK.</p><p>最后, 为了避免下次 brew upgrade 又出问题, 建议更新<code>zshrc</code>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/usr/local/opt/python@3.10/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/roxma/vim-hug-neovim-rpc/issues/47">Error Every time I load in vim8 (not neovim)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;踩了两次坑, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>今日宜出门</title>
    <link href="http://lupeipei.github.io/posts/the-right-to-walk-out/"/>
    <id>http://lupeipei.github.io/posts/the-right-to-walk-out/</id>
    <published>2022-04-29T10:21:27.000Z</published>
    <updated>2022-04-29T10:58:35.390Z</updated>
    
    <content type="html"><![CDATA[<p>被困了40多天, 小区终于熬成了防范区. 趁着门口一时无人看守, 溜了出去.</p><span id="more"></span><p>出门前, 在美团上看了下附近能送货的店, 先朝着不远的一家绝味鸭脖奔去.</p><p>沿路基本没什么人, 大部分店都关了.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images61651217381_.pic.jpg"></p><p>路过一个小区, 看到有人在理发.[后面那位黑衣大哥本来在排队, 看我在拍, 躲了过去, 理发师应该是骑车过来的, 袋里装了工具]</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images11651217376_.pic.jpg"></p><p>到店后, 店员说鸭脖没了, 要了锁骨, 问了下附近哪里有营业的超市, 告诉我说附近有家全家.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images41651217379_.pic.jpg"></p><p>去了最近的全家, 但是门上贴着暂停营业, 手机上查了下, 附近有家喜士多, 改奔喜士多.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images316512173781_.pic.jpg"></p><p>喜士多店门前放了两把椅子, 不让进店, 走近发现里面有店员.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images71651217382_.pic.jpg"></p><p>店里堆了不少纸箱, 店员直接从纸箱里拿商品.</p><p>买了薯片, 可乐之类, 店里的小哥问: 再给你来两袋花生? 好, 要得.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images51651217380_.pic.jpg"></p><p>拿到袋子的那一刻, 有一种”我真富有”的错觉…..</p><p>回去的路上, 偶遇了一顶帐篷, 帐篷里传出粗旷的男声, 在打电话.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images216512173771_.pic.jpg"></p><p>一路基本没什么行人, 马路上多数是开着电动车的外卖小哥,  偶尔会看到一些警车和120开过.</p><p>从来没有见到过这样的上海.</p><p>回去后, 开了瓶可乐, 听到了久违的气泡声.</p><p>恍如隔世.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被困了40多天, 小区终于熬成了防范区. 趁着门口一时无人看守, 溜了出去.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>读《费马大定理》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-fermat-s-last-theorem/"/>
    <id>http://lupeipei.github.io/posts/notes-of-fermat-s-last-theorem/</id>
    <published>2022-04-20T12:13:09.000Z</published>
    <updated>2022-04-21T02:08:52.093Z</updated>
    
    <content type="html"><![CDATA[<p>感谢这本书, 让我从封城的焦虑中，莫名其妙的平静了下来.</p><span id="more"></span><p>整本书围绕着费马大定理讲了很多个小故事, 这些故事里, 出现了很多熟悉的名字, 熟悉的定理或猜想, 有些甚至唤起了我久远的记忆, 看得时候时不时思路跳跃下, 哦, 原来以前中学课本上的这个人, 他在那个时代做了这么多事啊…….</p><p>鉴于书中穿插了一些数学方面较艰深的知识, 我也深知我这理解能力, 就不丢人了. 所以这里不打算细细缕一遍数学家安德鲁怀尔斯(Andrew Wiles)是如何在1993年证明了费马大定理的. 感兴趣的小伙伴可以看看2016年教授在哈佛的一场分享. [YouTube: <a href="https://www.youtube.com/watch?v=4t1mgEBx1nQ&list=WL">Andrew Wiles: Fermat’s Last theorem: abelian and non-abelian approaches</a> ]</p><p>这里就简单过一下整本书的主要内容, 然后再扯一扯书中提到的让我印象深刻的一些内容.</p><p>开始吧.</p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p>全书共８章, 采取了倒序的方式, 先简单描述了1993年那场费马大定理的证明, 随后从公元前6世纪的毕达哥拉斯学派开始, 作者讲述了费马大定理所基于的毕达哥拉斯定理的提出和证明, 然后娓娓道来古希腊最后一位数学卫士丢番图的著作《算术》是如何历经浩劫, 来到了17世纪的法国, 出现在了费马的书桌上, 至此, 故事才正式进入了正题. </p><p>17世纪的”业余数学家”费马在看《算术》时, 喜欢在书的页边处写写画画, 记录自己的思考. 而费马的这些注记在他过世后, 被数学家们注意到, 人们发现这些看似随意的注记, 包含了一系列的定理.</p><p>几个世纪后, 费马的这些评注一个接一个地被证明了, 只有费马大定理却固执地拒绝被征服。由于它是需要被证明的评注中的最后一个, 故称为 Fermat’s <strong>Last</strong> theorem. 中文译作费马大定理.</p><p>费马大定理的表述很简单:</p><pre><code>                      x^n + y^n = z^n, 当 n &gt; 2 时没有正整数解</code></pre><p>这个出谜的人, 还恶作剧地在书页中写下了这样的评注:</p><blockquote><p>Cuius rei demonstrationem mirabilem sane detexi hanc marginis exiguitas non caperet.<br>对这个命题, 我有一个十分美妙的证明，这里空白太小，写不下。</p></blockquote><p>随后的三个多世纪里, 无数的数学家为了证明费马大定理, 耗尽心力, 经历了从入门到放弃的心酸历程….</p><p>最先打破僵局的是18世纪的天才莱昂哈德·欧拉. </p><p>欧拉采用费马的无穷递降法, 通过将虚数引入到他的证明中, 成功地证明了n=3的情况. </p><p>随后的两个多世纪里, 数学家热尔曼, 柯西和拉梅,  库默尔都间接或者直接推动了费马大定理的证明. </p><p>20世纪中后期, 两位来自日本的数学家, 谷山丰和志村五郎, 在一次国际研讨会上提出了谷山志村猜想,  后经数学家弗赖的推理, 发现证明谷山志村猜想与证明费马大定理有着直接的关联. 1993年, 安德鲁怀尔斯通过证明谷山志村猜想, 证明了费马大定理.</p><p>整个故事到这也就讲完了.</p><p>事后怀尔斯讲述了这个从儿时就让他痴迷的定理, 对于他个人的意义:</p><blockquote><p>对我来说再也没有别的问题具有与费马大定理相同的意义，这是我童年时代的恋情，没有东西能取代它。 </p><p>我着迷于这个问题已经8年了，无时无刻——从早晨醒来到晚上入睡——我都在思考它。对于思考一件事那是一段太长的时光。那段特殊的漫长的探索现在结束了，我的心灵归于平静。 </p></blockquote><p>大概, 对于怀尔斯而言, 最大的收获不是名利, 而是心灵终于可以归于平静.</p><h4 id="质数加密和欧拉"><a href="#质数加密和欧拉" class="headerlink" title="质数加密和欧拉"></a>质数加密和欧拉</h4><p>书中涉及了数论, 几何, 概率论, 甚至群论等领域的专业知识, 很干货…….</p><p>写得很好, 我都没怎么看懂.</p><p>这里提一下比较惊喜的质数.</p><p>先来看看书中一段针对质数在密码学上的应用的描述, 涉及了公钥和私钥的生成逻辑.</p><blockquote><p>为了制成我自己的私人密钥，我会取两个大质数，每一个多达80个数字，然后将它们乘起来得到一个大得多的非质数。为了打乱信息所需要的一切，就是知道这个大的非质数，然而要整理信息则需要知道已经被乘在一起的原来的两个质数，它们称为质因数。现在我可以公开大的非质数，也即密钥中打乱信息的那一半，而自己保存那两个质因数，即密钥中整理信息的那一半。重要的是，即使人人都知道这个大的非质数，他们要判断出那两个质因数却仍然非常困难。</p></blockquote><p>这里提到的大的非质数, 构成了公钥, 而自己保存的那两个质因数, 构成了私钥.</p><p>是不是很熟悉?</p><p>著名的 RSA 非对称加密算法就是基于这个逻辑来的.</p><p>RSA 算法中通常选用512位的大质数p,q , 生成 1024 位的 n,  满足 n =  pq.</p><p>公钥是公开的, 含有 n,  私钥中包含仅自己知道的 { p, q }.</p><p>如果想要破解私钥, 就需要在已知 n 的情况下, 求解出大质数 p, q, 满足 n = pq, 这在数学上是非常难求解的. 甚至目前可以认为是不可能的.</p><p>我之前对RSA的实现并不理解, 现在再来看, 莫名觉得超级合理, 算是意外的惊喜.</p><p>书中后半部分涉及到了椭圆曲线，当时看得时候也挺意外的, 觉得BlockChain的那些开拓者们, 真是牛逼, 用的技术都是很前沿的数学方面的研究成果. 这里就不展开写了, 毕竟对椭圆曲线, 我是一脸懵逼…..</p><p>书中还提到了很多伟大的科学家, 不仅限于数学家, 也提及了计算机领域的冯诺伊曼和密码学方面的阿兰图灵. 但是让我印象深刻的, 却是欧拉.</p><p>如果说音乐大师中, 无法绕开失聪后依然高产的贝多芬, 那么在科学领域里, 不得不提天赋型选手欧拉, 他在失明后的17年里, 依然以惊人的速度产出学术论文, 在他的那个时代, 其产量之多, 无人能及. 据说彼得堡科学院为了整理他的著作, 足足忙碌了47年.</p><p>1707年, 欧拉生于瑞士巴塞尔, 其父为牧师, 欧拉最初服从他父亲的意愿, 研究神学并从事神职工作. 当时盛产数学家的伯努利家族也在巴塞尔, 欧拉的一位朋友来自伯努利家族, 他发现了欧拉在数学方面展现出来的天赋, 因为朋友的极力劝说, 欧拉最终选择从事数学研究. </p><blockquote><p>欧拉有着令人难以置信的直觉和超人的记忆力，据说他能够在头脑中详细列出一大堆完整无缺的演算式而无须用笔写在纸上。在整个欧洲他被誉为“分析的化身”，法国科学院院士弗朗索瓦·阿拉戈说，“欧拉计算时就像人呼吸或者鹰乘风飞翔一样无需明显的努力.”</p></blockquote><p>就这样, 这位半路出道的少年全身心投入到了数学的研究中, 并在随后的人生里持续高产, 在数学界留下了浓墨重彩的一笔.</p><p>值得一提的是, 与历史上一些终身未婚的科学家(柏拉图, 牛顿)不同, 欧拉27岁时,  迎娶了一位美术老师, 婚后两人育有十多个儿女. 暮年时儿孙绕膝.</p><p>真妥妥人生赢家.</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>因为上海封城，我体验了一把上一辈人被饥荒支配的恐慌,  加之时不时满屏的负面消息, 搞得整个人一度情绪低落，没想到刷完这本书后, 内心竟平静了许多, 算是意外的收获.</p><p>书中提到20世纪的希尔伯特, 一位一生致力于建立一个相容的数学体系的践行者, 他为了激励后来的数学家们, 在自己的墓碑上铭刻了这么一段话:</p><blockquote><p>Wir nüsssen wissen,<br>Wir werden wissen.</p><p>我们必须知道,</p><p>我们将会知道.</p></blockquote><p>不由得肃然起敬.</p><p>致敬所有在追寻真理的路上勇于开拓的人们, 是你们, 给了人类终将知道的底气.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://book.douban.com/subject/1322358/">费马大定理</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%98%82%E5%93%88%E5%BE%B7%C2%B7%E6%AD%90%E6%8B%89">wiki 莱昂哈德·欧拉</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢这本书, 让我从封城的焦虑中，莫名其妙的平静了下来.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Variables</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-variables/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-variables/</id>
    <published>2022-03-08T08:20:21.000Z</published>
    <updated>2022-03-08T08:30:58.439Z</updated>
    
    <content type="html"><![CDATA[<p>时隔一个多月没更了, 这频率委实慢了些😄️</p><p>虽慢但不弃坑, 来继续填坑😉.</p><p>从这一节开始, 我们正式来学 VimScript 的语法知识啦.</p><p>先从变量开始. 来看下变量的声明, 赋值及作用域.</p><h4 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h4><p>VimScript 使用 let 来声明变量.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">let</span> foo=<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">:<span class="built_in">echo</span> foo</span><br><span class="line">:<span class="built_in">let</span> foo=2</span><br><span class="line">:<span class="built_in">echo</span> foo</span><br></pre></td></tr></table></figure><p>会分别输出:</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bar</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>之前我们提到 option, option 可以通过 <code>&amp;&#123;option&#125;</code> 来做为变量进行读写操作.</p><p>看个例子:</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> textwidth=80</span><br><span class="line">:echo <span class="comment">&amp;textwidth</span></span><br><span class="line">:let <span class="comment">&amp;textwidth = &amp;textwidth + 10</span></span><br><span class="line">:echo <span class="comment">&amp;textwidth</span></span><br><span class="line">:<span class="keyword">set</span> <span class="comment">textwidth?</span></span><br></pre></td></tr></table></figure><p>会依次输出:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">80</span><br><span class="line">90</span><br><span class="line"><span class="attribute">textwidth</span>=90</span><br></pre></td></tr></table></figure><p>这里也可以看出, 把 option 转为变量, 使用 let 来更新 option 的值, 比 <code>set option=&#123;value&#125;</code> 要灵活一些.</p><p>如果只想针对当前 Window 的 option 进行写操作而不修改全局的 option, 只需要给变量添加相应的 namespace 即可.[其实是变量的作用域, 待会会提到]</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:let &amp;l:textwidth</span> = 10</span><br><span class="line">:echo &amp;textwidth</span><br></pre></td></tr></table></figure><p>此时输出是10. [我们也可以使用<code>:setlocal textwidth = 10</code> 来设置 local textwidth]</p><p>开一个新的 Window, 继续输出:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:e</span> text.txt</span><br><span class="line"><span class="symbol">:echo</span> &amp;textwidth</span><br></pre></td></tr></table></figure><p>此时输出是 90.</p><p>说明刚刚针对 textwidth 的修改, 只对前一个 Window 有效.</p><p>[ 这里需要在不同的 Windows 下进行上面的操作, 因为同一个 Window 下的 buffers 共享相同的 option,  如果在同一个 Window 下的不同 buffer 中执行 <code>:echo &amp;textwidth </code> , 输出都是10.]</p><p>除了 option 外, registers 也可以作为变量来进行读写. 格式为 <code>@&#123;register&#125;</code></p><p>比如, 我们设置寄存器 a 的值为 hello.</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> <span class="meta">@a</span>=<span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>Normal 模式下, 在文件的任何位置, 按<code>&quot;ap</code>,  Vim 会把 寄存器 a 的值 hello, 粘贴在光标处.</p><p>也可以读取寄存器的值. 在文件中, 选中某个单词, 比如 world, 按 <code>y</code> 后, 在命令行执行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">echo</span> @<span class="comment">&quot;</span></span><br></pre></td></tr></table></figure><p>会输出 world.</p><p>使用<code>:help registers</code> , 可以查看所有可以读写的寄存器.</p><p>除了声明变量外, 当我们想要删除某个变量时, 可以使用 <code>unlet</code>.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:unlet</span> foo</span><br><span class="line"><span class="symbol">:echo</span> foo</span><br></pre></td></tr></table></figure><p>此时会输出错误信息:  Undefined variable: foo.</p><p>注意, unlet 不能用于 <code>&amp;&#123;option&#125;</code>, <code>@&#123;register&#125;</code>.</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在设置 local option 时, 我们已经提到了作用域.</p><p>现在以 buffer 为例, 我们来定义一个 buffer-variable:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:let b:hello</span> = &quot;world&quot;</span><br><span class="line"><span class="meta">:echo b:hello</span></span><br></pre></td></tr></table></figure><p>输出: world.</p><p>在另一个 buffer 中, 执行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">echo</span> <span class="variable">b:hello</span></span><br></pre></td></tr></table></figure><p>输出: Undefined variable: b:hello.</p><p>因为声明的 b:hello 只对前一个 buffer 有效.</p><p>可以通过 <code>:help internal-variables</code> , 来查看内部变量的 scope 列表.</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">|<span class="type">buffer</span>-variable|    <span class="type">b</span>:  <span class="keyword">Local</span> to the current buffer.</span><br><span class="line">|<span class="type">window</span>-variable|    <span class="type">w</span>:  <span class="keyword">Local</span> to the current window.</span><br><span class="line">|<span class="type">tabpage</span>-variable|   <span class="type">t</span>:  <span class="keyword">Local</span> to the current tab page.</span><br><span class="line">|<span class="type">global</span>-variable|    <span class="type">g</span>:  <span class="keyword">Global</span>.</span><br><span class="line">|<span class="type">local</span>-variable|     <span class="type">l</span>:  <span class="keyword">Local</span> to a function.</span><br><span class="line">|<span class="type">script</span>-variable|    <span class="type">s</span>:  <span class="keyword">Local</span> to a |<span class="type">:source</span>|<span class="type">&#x27;ed</span> Vim script.</span><br><span class="line">|<span class="type">function</span>-argument|  <span class="type">a</span>:  <span class="keyword">Function</span> argument (only inside a function).</span><br><span class="line">|<span class="type">vim</span>-variable|       <span class="type">v</span>:  <span class="keyword">Global</span>, predefined <span class="built_in">by</span> Vim.</span><br></pre></td></tr></table></figure><p>这里可以看出, 刚刚我们通过<code>&amp;l:textwidth=&#123;value&#125;</code> 设置了textwidth, 我们可以猜 Vim 中的 <code>&#123;option&#125;</code>, <code>&#123;option&#125;=</code> 本质上应该是个函数.</p><p>上述列表中的 script-variable,  function-argument 大量存在plugin中，随意选择一个Vim 插件，查看其源代码，就会看到<code>s:var</code>, <code>a:var</code> 的身影.</p><p>OK, 变量的介绍就到这啦, 下一篇来说说 if.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时隔一个多月没更了, 这频率委实慢了些😄️&lt;/p&gt;
&lt;p&gt;虽慢但不弃坑, 来继续填坑😉.&lt;/p&gt;
&lt;p&gt;从这一节开始, 我们正式来学 VimScript 的语法知识啦.&lt;/p&gt;
&lt;p&gt;先从变量开始. 来看下变量的声明, 赋值及作用域.&lt;/p&gt;
&lt;h4 id=&quot;声明与赋值
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>深入解析CID</title>
    <link href="http://lupeipei.github.io/posts/what-is-cid/"/>
    <id>http://lupeipei.github.io/posts/what-is-cid/</id>
    <published>2022-03-03T11:20:14.000Z</published>
    <updated>2022-03-03T11:43:10.896Z</updated>
    
    <content type="html"><![CDATA[<p>这是 IPFS 相关内容的第一篇, 打算花点时间把之前自己刷 <a href="https://proto.school/tutorials">ProtoSchool</a> 系列课程所学到的知识梳理下.</p><p>第一篇就从 CID 开始吧. </p><span id="more"></span> <p>当然, 又一次, 强烈推荐刷原文 ,妥妥真香系列.</p><h4 id="是什么与为什么"><a href="#是什么与为什么" class="headerlink" title="是什么与为什么"></a>是什么与为什么</h4><p>CID 是 Content Identifier 的缩写, 中文可以译成内容标识符.</p><p>CID是用来做什么的呢?    </p><p>我们知道, 网络中用于标识资源的方式是统一资源标识符URI(Uniform Resource Identifier). </p><p>URI主要有两种类型: URL(Uniform Resource Locator) 和 URN( Uniform Resource Name).</p><p>在Web2.0中,  我们最常用的是URL. 即统一资源定位符, 资源基于数据存储的位置来寻址. 这种标识资源的方式, 可以称之为 Location addressing.</p><p>比如一张图片的URL 为<code>https://www.puppies.com/cute_cat.jpg</code> .我们会预设, 这是一个有关小猫照片的URL. 访问该URL后, 会看到一张猫咪的萌照.</p><p>那么URLs这种标识资源的方式会有什么问题呢?</p><blockquote><p>最主要的就是安全问题.</p><p>我们无法通过一个URL, 来验证这个URL给到我们的是我们想要的内容. 比如上面的URL, 可能打开后, 不是一张猫咪的萌照, 而是一张小狗的照片, 甚至可能会是一个木马病毒.</p><p>也就是说, 托管在中心化网络上的文件, 它们的内容与它们基于位置的地址 URLs 是没有直接关系的. 我们不能通过URLs或者文件名来确定资源的内容.</p><p>另一个存在的问题是大量重复的资源文件存储在相同或者不同的服务器上. 用户看到的是不同的URLs, 但这些URLs 所标识的都是完全一样的资源文件, 这就造成空间上不必要的浪费.</p></blockquote><p>那么, 能否有一种基于文件内容的标识符呢? 我们能否从 location-based addressing 转向 content-based addressing?</p><blockquote><p>答案当然是Yes : P</p><p>在去中心化的网络中, 资源的标识就是基于内容的.</p><p>针对任意给定的资源文件, 我们可以通过特定的算法, 为其生成唯一的识别码. 即Content addressing. </p><p>这里要介绍的CID, 就是一种特殊形式的内容寻址. </p><p>这种基于内容的资源标识方式, 相比URLs, 除了更安全, 避免资源冗余外,  还有一个优势.</p><p>在中心化的网络中, 当我们基于某个URLs去获取数据时, 如果该服务点挂了, 那我们就无法获取到数据了, 但是在去中心化的网络中, 我们只要有所需要资源的内容地址, 比如CID, 就可以向全网的节点发送请求.</p></blockquote><p>了解了是什么和为什么后, 我们来看看CID具体是怎么生成的.</p><h4 id="基本构成及演进"><a href="#基本构成及演进" class="headerlink" title="基本构成及演进"></a>基本构成及演进</h4><p>CID 由IPFS 开发. 一个常见的CID 长这样:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">QmY<span class="number">7</span>Yh<span class="number">4</span>UquoXHLPF<span class="meta">o2</span>XbhXkhBvFoPwmQUSa<span class="number">92</span>px<span class="symbol">nxjQuPU</span></span><br></pre></td></tr></table></figure><p>CID的大致创建过程, 是使用一种加密算法(cryptographic algorithm)，将任意大小的输入（数据或文件）映射到固定大小的输出。这种对于输入数据的转换, 称为加密哈希摘要(cryptographic hash digest)。</p><p>IPFS目前大部分CID是使用  <code>sha2-256</code> 算法, 也就是 256 bits, 32bytes. </p><p>从这里也可以看出, CID的长度, 是由 <strong>cryptographic hash</strong> 加密哈希算法来决定的, 而跟文件本身的大小无关. 任意长度的输入通过相同的哈希函数进行处理, 会得到固定长度的输出.</p><p>但鉴于哈希算法可能会被证明是不安全的,  比如 sha1 , 所以CID需要支持多种哈希算法.</p><p>既然要支持多种加密算法，那我们怎么知道这个特定的哈希值是使用哪种算法生成的呢?</p><p>CID 使用 multihash 来标识所用的加密算法.</p><p>具体就是<strong>将长度和使用的算法, 作为Hash值的唯一识别前缀</strong>.</p><h5 id="Multihash"><a href="#Multihash" class="headerlink" title="Multihash"></a>Multihash</h5><p>Multihash 遵循 TLV 模式, 即 <strong>T</strong>ype, <strong>L</strong>ength, <strong>V</strong>alue:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L02-multihash.jpeg"></p><p>Type</p><blockquote><p>标识所使用的加密算法 cryptographic algorithm. </p><p>通过 <a href="https://github.com/multiformats/multicodec/blob/master/table.csv">multicodec table</a> 可以查看对应的算法, 比如, <code>sha2-256</code>  的code 为 18, 用16进制表示则是 <code>0x12</code> </p></blockquote><p>Length</p><blockquote><p> 长度, 如果用的是<code>sha2-256</code> 算法, 则是32 bytes</p></blockquote><p>Value</p><blockquote><p>生成的哈希值</p></blockquote><p>当我们通过加密哈希摘要得到一个固定大小的输出时, 这个输出是二进制格式的. 对受众来说, 不是那么友好, 因此需要将其编码成字符串, 用字符串表示CID.</p><p>IPFS 最初是使用 base58btc 将二进制格式的哈希值, 进行编码压缩, 得到类似这样的结果:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">QmY<span class="number">7</span>Yh<span class="number">4</span>UquoXHLPF<span class="meta">o2</span>XbhXkhBvFoPwmQUSa<span class="number">92</span>px<span class="symbol">nxjQuPU</span></span><br></pre></td></tr></table></figure><p>以 Qm开头, 这也就是第一代CID v0.</p><p>但随之问题也就来了.</p><ul><li><p>我们如何得知程序是用什么方法对原数据本身进行了编码? 我们知道文件内保存数据的形式是二进制, 将二进制数据序列化用的是 protobuf 还是JSON, 抑或是其他 ？</p></li><li><p>我们如何得知程序是用什么方法来创建CID的字符串表示的? CIDv0 版本使用了 base58btc , 但是如果我们想要使用 base32 或者 base64 怎么办呢?</p></li></ul><p>为了解决这两个问题, CID不得不演进, 由此, CIDv1应运而生.</p><p>针对第一个问题,  CIDv1 引入了另外的前缀, 用来标识针对文件数据所使用的编码方式. 也就是 Multicodec Prefix.</p><p>这样, 我们的CID 就扩展成了这样:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L03-multicodec.png"></p><p>这里 Multicodec Prefix 的值是 01110000, 即 0x70, 查看<a href="https://github.com/multiformats/multicodec/blob/master/table.csv">codec identifier table</a>, 对应的就是 dag-pb. </p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220303145823.png"></p><p>dag-pb 表示 MerkleDAG protobuf, 是 <a href="https://ipld.io/">IPLD</a> (<strong>I</strong>nter<strong>P</strong>lanetary <strong>L</strong>inked <strong>D</strong>ata)的一种. [不懂 IPLD? 没事, 我暂时也没整明白, 先把 dag-pb 当作是一种特殊的 protobuf 看待, 不影响整体理解]</p><p>为了区分版本, CIDv1 还添加了 version prefix.</p><p>所以整个 CID 的构成就变成这样:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;cid-version&gt;</span><span class="section">&lt;multicodec&gt;</span><span class="section">&lt;multihash-algorithm&gt;</span><span class="section">&lt;multihash-length&gt;</span><span class="section">&lt;multihash-hash&gt;</span></span><br></pre></td></tr></table></figure><p>其中, cid-version 表示CID的版本.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L04-version-prefix.png"></p><p>针对第二个问题, 我们已经知道, CIDv0 中, 默认使用base58btc.</p><p>那么在CIDv1及之后的版本中, 如果我们使用了其他的编码方式, 如何让他人知道你使用的是哪种编码方法呢?</p><p>大概你也猜到了, 继续用前缀. [不得不叹一句: 前缀大法好]</p><p>Multibase prefix 就是用来表示在字符串和二进制格式之间转换CID时所使用的基础编码。</p><p>与前面Multicodec prefix 不同的是,  它不是放在二进制格式的输出结果中, 而是放在了转换后的字符串中.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L05-multibase-prefix.png"></p><p>来看两个字符串格式的CID:</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR</span></span><br><span class="line">bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi</span><br></pre></td></tr></table></figure><p>我们知道第一个CID是CIDv0, 因为它以Qm开头, 第二个以b开头, 表示编码方法为 base32.</p><p>通过查看完整的 <a href="https://github.com/multiformats/multibase/blob/master/multibase.csv">multibase</a> 表, 可以知道CID具体所采用的基础编码方法.</p><p>至此, 我们基本把CID的构成和演进理得差不多了.</p><p>如果你本地安装了ipfs,  通过命令行, 可以查看CID 的相关内容, 比如支持的base encoding:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs cid bases</span><br></pre></td></tr></table></figure><p>支持的 Cryptographic hashing  算法:</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ipfs cid hashes</span></span><br></pre></td></tr></table></figure><p>目前ipfs (0.11.0) 的CID, 依然默认是 v0 版本.</p><h4 id="在线解析"><a href="#在线解析" class="headerlink" title="在线解析"></a>在线解析</h4><p>考虑到CID的构成复杂,  IPFS提供了<a href="https://cid.ipfs.io/">CID inspector</a> 来帮助我们解析CID结果. </p><p>以 QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR 为例:</p><p>结果如下:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesimage-20220205151801443.png"></p><p>这里我们可以分别看到 multibase, version, muticodec, multihash对应的值.</p><p>稍稍提一下, 因为 multibase和 muticodec 是CIDv1后提出的, 而我们的CID 是v0版本的,  所以解析后, 这两部分显示了 implicit.</p><p>我们将解析后得到的CIDv1, 继续解析, 得到如下的结果:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesXnip2022-02-05_15-21-18.jpg"></p><p>此时, 我们看到multibase 为base32.</p><p>不管是 v0 还是 v1 的CID, 它们的摘要值都是C3C4…31DE94391A, 表示着同一份文件.</p><p>OK, 基本算是缕得差不多了, CID的内容就先到这啦.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI  wiki</a></p><p><a href="https://github.com/ipfs/go-ipfs">go-ipfs</a></p><p><a href="https://proto.school/anatomy-of-a-cid">Anatomy of a CID</a></p><p><a href="https://proto.school/content-addressing">content addressing</a></p><p><a href="https://github.com/multiformats/multicodec">multicodec</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 IPFS 相关内容的第一篇, 打算花点时间把之前自己刷 &lt;a href=&quot;https://proto.school/tutorials&quot;&gt;ProtoSchool&lt;/a&gt; 系列课程所学到的知识梳理下.&lt;/p&gt;
&lt;p&gt;第一篇就从 CID 开始吧. &lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="IPFS" scheme="http://lupeipei.github.io/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>Traefik 改用 acme.sh 为域名生成证书</title>
    <link href="http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/"/>
    <id>http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/</id>
    <published>2022-02-23T10:21:58.000Z</published>
    <updated>2022-02-23T10:40:47.471Z</updated>
    
    <content type="html"><![CDATA[<p>Traefik 踩坑记录.</p><span id="more"></span> <p>Traefik 可以配置自动生成证书的 ACME 供应商, 比如Let’s Encrypt.</p><p>官方文档提到会自动更新证书. 但实际情况是, 到期了证书有时并没有更新, 导致出现证书过期的情况. </p><p>这里记录下在服务器上配置 Traefik 时, 改用 acme.sh 来签证书并自动更新的步骤. </p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>默认服务器为Ubuntu, traefik 已启用, 对应的docker-compose.yml 存放在/opt/global目录下.</p><p>其中<code>/opt/global/docker-compose.yml</code> 的具体内容如下.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们挂载了/opt/global 目录下的 <code>traefik.toml</code>, 该文件存放了一些默认的配置, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">entryPoints</span>]</span><br><span class="line">  [<span class="string">entryPoints.web</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:80&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.websecure</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:443&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.traefik</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:8080&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">api</span>]</span><br><span class="line">  <span class="string">insecure</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">dashboard</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[<span class="string">log</span>]</span><br><span class="line">  <span class="string">level=</span> <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">certificatesResolvers</span>]</span><br><span class="line">  [<span class="string">certificatesResolvers.lets-encrypt</span>]</span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme</span>]</span><br><span class="line">      <span class="string">email</span> <span class="string">=</span> <span class="string">&quot;myEmail@gmail.com&quot;</span></span><br><span class="line">      <span class="string">storage</span> <span class="string">=</span> <span class="string">&quot;acme.json&quot;</span></span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme.tlsChallenge</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">providers.docker</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">exposedByDefault=false</span></span><br><span class="line">  <span class="string">network</span> <span class="string">=</span> <span class="string">&quot;my_proxy&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">providers.file</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">directory=&quot;/providers&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到我们声明了一个证书解析器 (certificatesResolvers)  lets-encrypt. </p><p>而 我们需要使用 acme.sh 生成证书的 Web项目, 存放在/opt/web/ 下, 其 <code>docker-compose.yml</code> 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.entrypoints=web&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.middlewares=my-web-https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.middlewares.my-web-https.redirectscheme.scheme=https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.certresolver=lets-encrypt&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里可以看到, 我们给 web 配置的 certresolver 配置为之前定义的 lets-encrypt. </p><p> 如果查看 <code>acme.json</code> 文件, 你会看到类似如下内容, Certificates 部分有我们的 <code>example.com</code> 及子域名<code>api.example.com</code>  :</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lets-encrypt&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Account&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Email&quot;</span>: <span class="string">&quot;myEmail@gmail.com&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Registration&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;valid&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;contact&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;mailto:myEmail@gmail.com&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;https://acme-v02.api.letsencrypt.org/acme/acct/xxxxx&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;PrivateKey&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;KeyType&quot;</span>: <span class="string">&quot;4096&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Certificates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example.com&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sans&quot;</span>: [<span class="string">&quot;api.example.com&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example1.com&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      .........</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时, 网站正常访问.</p><p>现在我们来更改 <code>example.com</code> 的 tls 配置, 证书改用 acme.sh 来签发.</p><h4 id="改用-acme-sh"><a href="#改用-acme-sh" class="headerlink" title="改用 acme.sh"></a>改用 acme.sh</h4><p>acme 验证的主要方式是 standalone 和 webroot.</p><p>鉴于 standalone 需要占用80或者443端口, 导致需要暂停服务器,这里我们使用 webroot 方式来验证域名.</p><p> webroot 模式下, acme 会在网站根目录下生成一个临时子目录 <code>.well-known/acme-challenge</code>，然后服务器会向这个路径发请求，如果请求成功，则验证通过, 随后会删除掉这个临时目录. </p><p>我们将根目录web root 默认为 /var/www, 同时在当前目录下, 新增两个文件夹, 用来分别挂载 /var/www 和 /acme.sh 目录.</p><p>/opt/global/ 目录下, 新建文件 <code>docker-compose.acme.sh.yml</code>, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">acme.sh:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">neilpang/acme.sh:3.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">acme.sh</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/var/www</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">daemon</span></span><br></pre></td></tr></table></figure><p>新增文件夹:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir nginx acme.sh</span><br></pre></td></tr></table></figure><p>生成的证书会存放在acme.sh 目录中, 而 nginx 目录用于验证域名.</p><p>这里我们起一个nginx 服务, 使得 traefik 将所有匹配 <code>/.well-known</code> 的路径请求都转发到这个nginx 上. 同时, 将当前目录下的 nginx 目录挂载到 nginx 服务的静态文件默认地址 <code>/usr/share/nginx/html</code> . </p><p>这样, 当使用 webroot 模式验证域名时, acme.sh 就会在 <code>/opt/global/nginx</code> 目录下,生成临时子目录 <code>.well-known/acme-challenge</code>, 而验证时, 访问 <code>/usr/share/nginx/html</code>, 也就是访问我们的 <code>/opt/global/nginx</code> 目录.</p><p>我们新增文件 <code>/opt/global/docker-compose.nginx.yml</code> , 添加如下内容:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.rule=HostRegexp(`&#123;catch_all:.*&#125;`) &amp;&amp; PathPrefix(`/.well-known`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.priority=999&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.global-nginx.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里有一点需要提一下.</p><p>我们给 nginx 服务配置 traefik 时,  设置了priority的值为999. 默认情况下,  traefik 中路径的 priority是根据rule的长度来决定的. 这里我们希望所有带有 <code>/.well-known</code> 的请求都转发到这个 nginx 上, 所以手动设置了999.</p><p>启动 nginx:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.nginx.yml up -d</span><br></pre></td></tr></table></figure><p>nginx 启动后, 我们启动 acme.sh.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.acme.sh.yml up -d</span><br></pre></td></tr></table></figure><p>开始签证书啦.</p><p>第一次使用acme.sh时, 需要注册用户邮箱:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it acme.sh sh -l</span><br><span class="line">acme.sh --register-account -m myEmail@gmail.com</span><br><span class="line">acme.sh --issue -d example.com -d api.example.com --webroot /var/www</span><br></pre></td></tr></table></figure><p>正常情况下, 会一切顺利. 默认CA是ZeroSSL.com</p><p>如果 acme.sh 签发证书时 Timeout了, 请设置代理. </p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><p>证书签发成功后, 我们查看 <code>/opt/global/acme.sh/example.com</code> 目录, 会看到刚刚生成的证书.</p><p>现在, 我们把新鲜出炉的证书用起来.</p><p>修改 <code>/opt/global/docker-compose.yml</code> , 将 <code>/opt/global/acme.sh</code> 目录挂载到 traefik 中:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br></pre></td></tr></table></figure><p>然后我们在traefik 的动态配置中把证书放进去.</p><p>在 <code>/opt/global/providers</code> 目录下, 新增 <code>example_com_certs.toml</code> 文件, 写入我们的证书路径:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[tls.certificates]]</span></span><br><span class="line">  <span class="attr">certFile</span> = <span class="string">&quot;/acme.sh/example.com/fullchain.cer&quot;</span></span><br><span class="line">  <span class="attr">keyFile</span> = <span class="string">&quot;/acme.sh/example.com/example.com.key&quot;</span></span><br></pre></td></tr></table></figure><p>同时, 我们需要将 <code>/opt/global/acme.json</code> 文件中 Certificates 部分, 有关 example.com 的证书内容删除.</p><p>最后, 修改 <code>/opt/web/docker-compose.yml</code>, 把tls 部分的配置, 改为options=default.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.options=default&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br></pre></td></tr></table></figure><p>重启 traefik.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart traefik</span><br></pre></td></tr></table></figure><p>再次请求 <a href="https://example.com/">https://example.com</a>, 会发现证书已经签成由ZeroSSL 颁发的证书. </p><p>替换完成. 撒花! 🥳</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://doc.traefik.io/traefik/">traefik doc</a></p><p><a href="https://doc.traefik.io/traefik/https/acme/">traefick: let’s Encrypt</a></p><p><a href="https://github.com/acmesh-official/acme.sh">acme.sh</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traefik 踩坑记录.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Acme" scheme="http://lupeipei.github.io/tags/Acme/"/>
    
      <category term="Traefik" scheme="http://lupeipei.github.io/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>Using Puppeteer with executablePath in Electron</title>
    <link href="http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/"/>
    <id>http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/</id>
    <published>2022-02-15T08:31:40.000Z</published>
    <updated>2022-02-22T06:37:44.224Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Electron 踩坑过程.</p><span id="more"></span> <h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用 Electron 创建桌面应用, 程序中调用了 <a href="https://github.com/puppeteer/puppeteer">puppeteer</a>,  开发环境下一切正常, 使用 electron-builder 在Mac上打包成 Windows下的可执行文件后, 程序在Windows上跑时一直卡着不动.</p><p>Debug后发现一直卡在 <code>puppeteer.launch</code> .</p><p>环境:</p><p>puppeteer: 13.0.1</p><p>electron: 17.0.0</p><p>electron-builder: 22.10.4</p><p>node: 12.22.3</p><p>yarn: 1.22.10</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>Debug后发现问题的根源在于 MacOS 上打包时,  node_module 中 puppeteer 的Chrome, 是适配MacOS系统版本的, 这个Chrome 在 Windows下肯定是无法正常运行的.</p><p>参考<a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a> 中, scriptify 的回复:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagespuppeteer.jpg"></p><p>自己写一个脚本, 本地下载个Windows版本的chrome, 然后打包进去, <code>puppeteer.launch</code> 时指定 executablePath.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载 chrome.</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browserFetcher = puppeteer.createBrowserFetcher(&#123; <span class="attr">platform</span>: <span class="string">&quot;win32&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> revisionInfo = <span class="keyword">await</span> browserFetcher.download(<span class="string">&#x27;533271&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(revisionInfo)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>按照 scriptify 给的方法, 修改package.json:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;asar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;asarUnpack&quot;</span>: <span class="string">&quot;node_modules/puppeteer/.local-chromium/win32-533271/**/*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用 <code>puppeteer.launch</code> 的地方:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> homeDir = puppeteer.executablePath().split(<span class="string">&#x27;app.asar&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> executablePath = homeDir.concat(<span class="string">&quot;app.asar.unpacked\\node_modules\\puppeteer\\.local-chromium\\win32-533271\\chrome-win32\\chrome.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: executablePath, <span class="attr">args</span>: [ <span class="string">&quot;--disable-gpu&quot;</span>, <span class="string">&quot;--disable-dev-shm-usage&quot;</span>, <span class="string">&quot;--disable-setuid-sandbox&quot;</span>, <span class="string">&quot;--no-sandbox&quot;</span> ] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>诡异的是, 打包后扔进 Windows里面运行, 发现 Chrome.exe 文件是存在的. 但是 puppeteer 依然没有成功运行.</p><p>最后无奈, 直接换成 在Windows下打包, 同时指定 executablePath.问题解决.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a></p><p><a href="https://yrq110.me/post/front-end/the-right-way-to-use-puppeteer-in-electron/">配置Electron中Puppeteer executablePath的正确姿势</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Electron 踩坑过程.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>As I began to love myself</title>
    <link href="http://lupeipei.github.io/posts/as-I-began-to-love-myself/"/>
    <id>http://lupeipei.github.io/posts/as-I-began-to-love-myself/</id>
    <published>2022-02-13T13:53:12.000Z</published>
    <updated>2022-04-26T08:14:18.568Z</updated>
    
    <content type="html"><![CDATA[<p>读到一首不错的现代诗, 分享下 ^_^</p><span id="more"></span><p>As I began to love myself,<br>I found that anguish and emotional suffering are only warning signs that I was living against my own truth.<br>Today, I know, this is “authenticity”.</p><p>As I began to love myself,<br>I understood how much it can offend somebody,<br>As I try to force my desires on this person, even though I knew the time was not right and the person was not ready for it, and even though this person was me.<br>Today I call it “respect”.</p><p>As I began to love myself,<br>I stopped craving for a different life, and I could see that everything that surrounded me was inviting me to grow.<br>Today I call it “maturity”.</p><p>As I began to love myself,<br>I understood that at any circumstance, I am in the right place at the right time, and everything happens at the exactly right moment.<br>So I could be calm.<br>Today I call it “self-confidence”.</p><p>As I began to love myself,<br>I quit steeling my own time, and I stopped designing huge projects for the future.<br>Today, I only do what brings me joy and happiness, things I love to do and that make my heart cheer, and I do them in my own way and in my own rhythm.<br>Today I call it “simplicity”.</p><p>As I began to love myself,<br>I freed myself of anything that is no good for my health – food, people, things, situations, and everything that drew me down and away from myself.<br>At first I called this attitude a healthy egoism.<br>Today I know it is “love of oneself”.</p><p>As I began to love myself,<br>I quit trying to always be right, and ever since I was wrong less of the time.<br>Today I discovered that is “modesty”.</p><p>As I began to love myself,<br>I refused to go on living in the past and worry about the future.<br>Now, I only live for the moment, where everything is happening.<br>Today I live each day, day by day, and I call it “fulfillment”.</p><p>As I began to love myself,<br>I recognized that my mind can disturb me and it can make me sick.<br>But as I connected it to my heart, my mind became a valuable ally.<br>Today I call this connection “wisdom of the heart”.</p><p>We no longer need to fear arguments, confrontations or any kind of problems with ourselves or others.<br>Even stars collide, and out of their crashing new worlds are born.<br>Today I know “that is life”.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读到一首不错的现代诗, 分享下 ^_^&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
      <category term="Poem" scheme="http://lupeipei.github.io/tags/Poem/"/>
    
  </entry>
  
  <entry>
    <title>electron 代理配置</title>
    <link href="http://lupeipei.github.io/posts/set-proxy-for-electron/"/>
    <id>http://lupeipei.github.io/posts/set-proxy-for-electron/</id>
    <published>2022-02-07T12:10:53.000Z</published>
    <updated>2022-02-07T12:27:02.284Z</updated>
    
    <content type="html"><![CDATA[<p>踩了两次坑, 记录下.</p><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>node version: v12.22.3<br>yarn version: 1.22.10</p><p>终端执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>一直报错:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Output:</span></span><br><span class="line"><span class="symbol">RequestError:</span> read ETIMEDOUT</span><br></pre></td></tr></table></figure><p>已经设置了代理, 无效:</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">http_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">all_proxy=socks5:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7891</span></span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>参考 <a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a>, node 10+需要设置环境变量.<br><code>GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE</code> 采用默认值<code>GLOBAL_AGENT_</code></p><p>分别设置 <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTP_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTPS_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ELECTRON_GET_USE_PROXY</span>=1</span><br></pre></td></tr></table></figure><p>重新执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>OK.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;踩了两次坑, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Operator Pending Mappings</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/</id>
    <published>2022-01-13T13:37:12.000Z</published>
    <updated>2022-01-13T13:41:55.207Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. </p><p>官方文档中, 对 Operator-pending mappings 的解释是:</p><blockquote><p>Operator-pending mappings can be used to define a movement command that can be<br>used with any operator. </p></blockquote><p>Operator-pending mappings 可以用于定义会被执行的移动指令.[我这翻译的…]</p><p>看个简单的例子来理解.</p><p>打开文件test.txt, 内容如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> (<span class="keyword">some</span>) <span class="built_in">text</span> <span class="keyword">about</span> topic one.</span><br><span class="line"></span><br><span class="line">It has multiple (<span class="built_in">paragraphs</span>).</span><br><span class="line">part1(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part2(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part3(<span class="built_in">paragraph</span>) content.</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>命令模式下, 执行:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">onoremap</span> <span class="selector-tag">p</span> <span class="selector-tag">i</span>(</span><br></pre></td></tr></table></figure><p>这时, 在 normal 模式下, 按<code>dp</code>, 等同于<code>di(</code>, 即删除<code>()</code> 里的内容.</p><p>这里默认从当前光标所在位置, 往下查找第一个<code>()</code>, 然后执行操作.</p><p>比如, 我们把光标移动到第三行 It has……, 按<code>dp</code>,  会发现 paragraphs 被删除了.</p><p>当光标停留在最后一行 end, 按<code>dp</code>, 发现无效.</p><p>如果想要消除光标所在位置, 就需要使用<code>&lt;C-u&gt;</code> CTRL-u.</p><p>来看个例子:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:onoremap i( :&lt;C-u&gt;normal!</span> 0f)vi(&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>此时, 按<code>di(</code>, 不管光标在哪里, 会删除光标所在行的第一个<code>()</code> 中的内容.</p><p>鉴于 Operator-pending mappings 我平时用到的很少, 也没有细细研究, 目前就不多扯了.</p><p>想要了解更多, 可以看官方文档:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">:h omap-<span class="meta">info</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. &lt;/p&gt;
&lt;p&gt;官方文档中, 对 Operator-pending mappings 的解释是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Operator-pending map
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Status Lines</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-statusline/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-statusline/</id>
    <published>2022-01-10T07:48:42.000Z</published>
    <updated>2022-10-19T23:50:10.324Z</updated>
    
    <content type="html"><![CDATA[<p>来看看如何自定义状态栏显示.</p><p>Statusline 是 Vim 的一个 option, 可通过:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>查看当前的 statusline 配置.</p><p>当然, 我们也可以自定义状态栏的显示内容.</p><p>打开一个Markdown 文件,  命令行模式下, 输入:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=%f\ -\ FileType:\</span> %y</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo<span class="selector-class">.md</span> - FileType: <span class="selector-attr">[markdown]</span></span><br></pre></td></tr></table></figure><p>这里的 <code>%f</code>表示当前文件的相对路径, <code>%y </code> 表示文件的类型.</p><p>statusline 的设置, 有些类似 C 里面的 printf.</p><p>它的通用格式如下:</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">%-0</span><span class="template-variable">&#123;minwid&#125;</span><span class="xml">.</span><span class="template-variable">&#123;maxwid&#125;</span><span class="template-variable">&#123;item&#125;</span></span><br></pre></td></tr></table></figure><p>其中, 除了<code>%</code>  和 <code>&#123;item&#125;</code>, 其他都是可选的. 而 minwd, maxwid 分别指的是最小和最大宽度.</p><p>看几个简单的例子就清楚了.</p><p>显示行号:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %4l\ Total:\ %4L</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>:    <span class="number">9</span> Total:   <span class="number">66</span></span><br></pre></td></tr></table></figure><p>这里设置了最短长度4, 默认用空格来补全.</p><p>可以设置为用0来补全:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %04l\ Total:\ %04L</span><br></pre></td></tr></table></figure><p>状态栏显示如下:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>: <span class="number">0009</span> Total: <span class="number">0066</span></span><br></pre></td></tr></table></figure><p>再比如, 显示文件的绝对路径:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> <span class="attribute">statusline</span>=%.20F</span><br></pre></td></tr></table></figure><p>此处, 最大宽度设置为20, 状态栏显示如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;-<span class="keyword">on</span>-buffer-<span class="keyword">local</span>.md</span><br></pre></td></tr></table></figure><p>通过 <code>:h statusline</code> , 可以查看所有可用的 item 及其对应含义.</p><p>此外, 如果 statusline 是以 <code>%!</code> 开头, 比如 <code>:set statusline=%!MyStatusLine()</code> , 则表示<code>MyStatusLine()</code> 是个表达式, 这个表达式的结果才是 statusline 对应的值.</p><p>如果你安装了airline, 命令模式输入:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>会看到输出结果:</p><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line">statusline=%!airline<span class="function"><span class="keyword">#</span><span class="title">statusline</span><span class="params">(1)</span></span></span><br></pre></td></tr></table></figure><p>这里就是使用了<code>%!</code>.</p><p>书中还介绍了<code>%=</code>, 用于对齐, 这里就略过了.</p><p>OK, 本节结束, 我去吃点好吃的奖励下自己还没弃坑😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来看看如何自定义状态栏显示.&lt;/p&gt;
&lt;p&gt;Statusline 是 Vim 的一个 option, 可通过:&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Autocmd</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/</id>
    <published>2021-12-31T09:31:55.000Z</published>
    <updated>2022-10-19T23:49:13.898Z</updated>
    
    <content type="html"><![CDATA[<p>autocmd 用于配置当某个确定事件发生时, 要执行的命令.</p><p>借用书中的例子, 看一下 autocmd 的基本结构:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:autocmd BufWritePre,BufRead *.html :normal</span> gg=G</span><br><span class="line"><span class="code">         ^                   ^      ^</span></span><br><span class="line"><span class="code">         |                   |      |</span></span><br><span class="line"><span class="code">         |                   |      需要执行的命令</span></span><br><span class="line"><span class="code">         |                   |</span></span><br><span class="line"><span class="code">         |                   模式, 用来过滤事件</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="code">         监听的事件</span></span><br></pre></td></tr></table></figure><p>这里 BufWritePre, BufRead 都是需要监听的事件, *.html 是需要过滤的模式, 整个命令的含义就是, 当开始写入 html 类型文件或者编辑 html 类型文件之前, 自动执行<code>:normal gg=G</code>, 也就是缩进代码.</p><p>[此处, BufWritePre 指的是开始将整个 Buffer 写入文件 , BufRead 指的是读文件后, 开始编辑. ]</p><p>通过<code>:h autocmd-events</code> 可以查看所有可以绑定 Autocommands 的事件列表.</p><p>其中, 最常用的 Event 是 FileType.</p><p>比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">autocmd</span> FileType javascript <span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;LocalLeader&gt;</span><span class="keyword">c</span> I//<span class="symbol">&lt;esc&gt;</span></span><br></pre></td></tr></table></figure><p>当打开一个javascript (.js)文件时, 执行<code>nnoremap &lt;buffer&gt; &lt;LocalLeader&gt;c I//&lt;esc&gt;</code>, 也就是按 <code>&lt;LocalLeader&gt;c</code>  会添加注释.</p><p>这里提一个简单的应用.</p><p>Vim中编辑 json 文件的时候, 默认是没有格式化的, 如何实现打开JSON文件时, 自动格式化内容, 方便阅读?</p><p>这里说一下我的做法.</p><p>安装 jq, 附上链接<a href="https://stedolan.github.io/jq/download/">download</a></p><p>修改 <code>.vimrc </code>, 添加:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">autocmd <span class="keyword">BufRead </span>*.<span class="keyword">json </span>%!<span class="keyword">jq </span><span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure><p>source 后, 打开 json 格式文件时, 可以看到已经格式化了.</p><p>autocmd 有一个兄弟 augroup. 可以把相近的 autocmd 放在一个group 中:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">augroup</span> testgroup</span><br><span class="line">  autocmd!</span><br><span class="line">  <span class="keyword">autocmd</span> BufWrite * :<span class="keyword">echom</span> <span class="string">&quot;Cats&quot;</span></span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p>这里使用<code>autocmd!</code>  来清理之前的 autocmd 设置.</p><p>augroup 的作用, 是用来避免重复定义 autocmd. 官网文档给到的解释是:</p><blockquote><p>This prevents having the autocommands defined twice (e.g., after sourcing the .vimrc file again).</p></blockquote><p>书中使用了一个 BufWrite + echom 的例子来说明使用 augroup 可以避免的问题, 同文档提到的一致, 这里就不细说了.</p><p>附上一个小小的tips. 如果你有执行 augroup 的例子, 会发现 messages 有些多,  想要清理的话, 可以使用<code>:messages clear</code></p><p>OK, 本章结束.</p><p>Bye 2021.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;autocmd 用于配置当某个确定事件发生时, 要执行的命令.&lt;/p&gt;
&lt;p&gt;借用书中的例子, 看一下 autocmd 的基本结构:&lt;/p&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
</feed>
