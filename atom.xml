<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucia</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lupeipei.github.io/"/>
  <updated>2022-05-07T08:02:36.054Z</updated>
  <id>http://lupeipei.github.io/</id>
  
  <author>
    <name>Lucia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>deoplete failed to init in Vim8</title>
    <link href="http://lupeipei.github.io/posts/deoplete-fail-to-init-in-vim8/"/>
    <id>http://lupeipei.github.io/posts/deoplete-fail-to-init-in-vim8/</id>
    <published>2022-05-07T07:59:59.000Z</published>
    <updated>2022-05-07T08:02:36.054Z</updated>
    
    <content type="html"><![CDATA[<p>踩了两次坑, 记录下.</p><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>执行<code>brew upgrade </code> 后, 终端打开 <code>.vimrc</code> 文件一直报错:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220507151533.png"></p><p>显示 [vim-hug-neovim-rpc] requires one of  <code>:pythonx import [pynvm|neovim]</code>.</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><a href="https://github.com/roxma/vim-hug-neovim-rpc">vim-hug-neovim-rpc</a> 的 Issues  <a href="https://github.com/roxma/vim-hug-neovim-rpc/issues/47">Error Every time I load in vim8 (not neovim)</a> 提到了这个.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220507152627.png"></p><p>Vim 跑了下<code>:pythonx import sys; print(sys.path)</code>,  发现Vim里面用的Python是3.10. </p><p>而我本地的 python3 版本却是 3.7.9.  猜测<code>brew upgrade</code> 后,  relink了3.7.9?</p><p>参考上面的解法, 终端执行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/opt/python@3.10/bin/pip3 install pynvim</span><br></pre></td></tr></table></figure><p>再次打开<code>.vimrc</code>, 无报错. OK.</p><p>最后, 为了避免下次 brew upgrade 又出问题, 建议更新<code>zshrc</code>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/usr/local/opt/python@3.10/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/roxma/vim-hug-neovim-rpc/issues/47">Error Every time I load in vim8 (not neovim)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;踩了两次坑, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>今日宜出门</title>
    <link href="http://lupeipei.github.io/posts/the-right-to-walk-out/"/>
    <id>http://lupeipei.github.io/posts/the-right-to-walk-out/</id>
    <published>2022-04-29T10:21:27.000Z</published>
    <updated>2022-04-29T10:58:35.390Z</updated>
    
    <content type="html"><![CDATA[<p>被困了40多天, 小区终于熬成了防范区. 趁着门口一时无人看守, 溜了出去.</p><span id="more"></span><p>出门前, 在美团上看了下附近能送货的店, 先朝着不远的一家绝味鸭脖奔去.</p><p>沿路基本没什么人, 大部分店都关了.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images61651217381_.pic.jpg"></p><p>路过一个小区, 看到有人在理发.[后面那位黑衣大哥本来在排队, 看我在拍, 躲了过去, 理发师应该是骑车过来的, 袋里装了工具]</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images11651217376_.pic.jpg"></p><p>到店后, 店员说鸭脖没了, 要了锁骨, 问了下附近哪里有营业的超市, 告诉我说附近有家全家.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images41651217379_.pic.jpg"></p><p>去了最近的全家, 但是门上贴着暂停营业, 手机上查了下, 附近有家喜士多, 改奔喜士多.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images316512173781_.pic.jpg"></p><p>喜士多店门前放了两把椅子, 不让进店, 走近发现里面有店员.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images71651217382_.pic.jpg"></p><p>店里堆了不少纸箱, 店员直接从纸箱里拿商品.</p><p>买了薯片, 可乐之类, 店里的小哥问: 再给你来两袋花生? 好, 要得.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images51651217380_.pic.jpg"></p><p>拿到袋子的那一刻, 有一种”我真富有”的错觉…..</p><p>回去的路上, 偶遇了一顶帐篷, 帐篷里传出粗旷的男声, 在打电话.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images216512173771_.pic.jpg"></p><p>一路基本没什么行人, 马路上多数是开着电动车的外卖小哥,  偶尔会看到一些警车和120开过.</p><p>从来没有见到过这样的上海.</p><p>回去后, 开了瓶可乐, 听到了久违的气泡声.</p><p>恍如隔世.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被困了40多天, 小区终于熬成了防范区. 趁着门口一时无人看守, 溜了出去.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>读《费马大定理》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-fermat-s-last-theorem/"/>
    <id>http://lupeipei.github.io/posts/notes-of-fermat-s-last-theorem/</id>
    <published>2022-04-20T12:13:09.000Z</published>
    <updated>2022-04-21T02:08:52.093Z</updated>
    
    <content type="html"><![CDATA[<p>感谢这本书, 让我从封城的焦虑中，莫名其妙的平静了下来.</p><span id="more"></span><p>整本书围绕着费马大定理讲了很多个小故事, 这些故事里, 出现了很多熟悉的名字, 熟悉的定理或猜想, 有些甚至唤起了我久远的记忆, 看得时候时不时思路跳跃下, 哦, 原来以前中学课本上的这个人, 他在那个时代做了这么多事啊…….</p><p>鉴于书中穿插了一些数学方面较艰深的知识, 我也深知我这理解能力, 就不丢人了. 所以这里不打算细细缕一遍数学家安德鲁怀尔斯(Andrew Wiles)是如何在1993年证明了费马大定理的. 感兴趣的小伙伴可以看看2016年教授在哈佛的一场分享. [YouTube: <a href="https://www.youtube.com/watch?v=4t1mgEBx1nQ&list=WL">Andrew Wiles: Fermat’s Last theorem: abelian and non-abelian approaches</a> ]</p><p>这里就简单过一下整本书的主要内容, 然后再扯一扯书中提到的让我印象深刻的一些内容.</p><p>开始吧.</p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p>全书共８章, 采取了倒序的方式, 先简单描述了1993年那场费马大定理的证明, 随后从公元前6世纪的毕达哥拉斯学派开始, 作者讲述了费马大定理所基于的毕达哥拉斯定理的提出和证明, 然后娓娓道来古希腊最后一位数学卫士丢番图的著作《算术》是如何历经浩劫, 来到了17世纪的法国, 出现在了费马的书桌上, 至此, 故事才正式进入了正题. </p><p>17世纪的”业余数学家”费马在看《算术》时, 喜欢在书的页边处写写画画, 记录自己的思考. 而费马的这些注记在他过世后, 被数学家们注意到, 人们发现这些看似随意的注记, 包含了一系列的定理.</p><p>几个世纪后, 费马的这些评注一个接一个地被证明了, 只有费马大定理却固执地拒绝被征服。由于它是需要被证明的评注中的最后一个, 故称为 Fermat’s <strong>Last</strong> theorem. 中文译作费马大定理.</p><p>费马大定理的表述很简单:</p><pre><code>                      x^n + y^n = z^n, 当 n &gt; 2 时没有正整数解</code></pre><p>这个出谜的人, 还恶作剧地在书页中写下了这样的评注:</p><blockquote><p>Cuius rei demonstrationem mirabilem sane detexi hanc marginis exiguitas non caperet.<br>对这个命题, 我有一个十分美妙的证明，这里空白太小，写不下。</p></blockquote><p>随后的三个多世纪里, 无数的数学家为了证明费马大定理, 耗尽心力, 经历了从入门到放弃的心酸历程….</p><p>最先打破僵局的是18世纪的天才莱昂哈德·欧拉. </p><p>欧拉采用费马的无穷递降法, 通过将虚数引入到他的证明中, 成功地证明了n=3的情况. </p><p>随后的两个多世纪里, 数学家热尔曼, 柯西和拉梅,  库默尔都间接或者直接推动了费马大定理的证明. </p><p>20世纪中后期, 两位来自日本的数学家, 谷山丰和志村五郎, 在一次国际研讨会上提出了谷山志村猜想,  后经数学家弗赖的推理, 发现证明谷山志村猜想与证明费马大定理有着直接的关联. 1993年, 安德鲁怀尔斯通过证明谷山志村猜想, 证明了费马大定理.</p><p>整个故事到这也就讲完了.</p><p>事后怀尔斯讲述了这个从儿时就让他痴迷的定理, 对于他个人的意义:</p><blockquote><p>对我来说再也没有别的问题具有与费马大定理相同的意义，这是我童年时代的恋情，没有东西能取代它。 </p><p>我着迷于这个问题已经8年了，无时无刻——从早晨醒来到晚上入睡——我都在思考它。对于思考一件事那是一段太长的时光。那段特殊的漫长的探索现在结束了，我的心灵归于平静。 </p></blockquote><p>大概, 对于怀尔斯而言, 最大的收获不是名利, 而是心灵终于可以归于平静.</p><h4 id="质数加密和欧拉"><a href="#质数加密和欧拉" class="headerlink" title="质数加密和欧拉"></a>质数加密和欧拉</h4><p>书中涉及了数论, 几何, 概率论, 甚至群论等领域的专业知识, 很干货…….</p><p>写得很好, 我都没怎么看懂.</p><p>这里提一下比较惊喜的质数.</p><p>先来看看书中一段针对质数在密码学上的应用的描述, 涉及了公钥和私钥的生成逻辑.</p><blockquote><p>为了制成我自己的私人密钥，我会取两个大质数，每一个多达80个数字，然后将它们乘起来得到一个大得多的非质数。为了打乱信息所需要的一切，就是知道这个大的非质数，然而要整理信息则需要知道已经被乘在一起的原来的两个质数，它们称为质因数。现在我可以公开大的非质数，也即密钥中打乱信息的那一半，而自己保存那两个质因数，即密钥中整理信息的那一半。重要的是，即使人人都知道这个大的非质数，他们要判断出那两个质因数却仍然非常困难。</p></blockquote><p>这里提到的大的非质数, 构成了公钥, 而自己保存的那两个质因数, 构成了私钥.</p><p>是不是很熟悉?</p><p>著名的 RSA 非对称加密算法就是基于这个逻辑来的.</p><p>RSA 算法中通常选用512位的大质数p,q , 生成 1024 位的 n,  满足 n =  pq.</p><p>公钥是公开的, 含有 n,  私钥中包含仅自己知道的 { p, q }.</p><p>如果想要破解私钥, 就需要在已知 n 的情况下, 求解出大质数 p, q, 满足 n = pq, 这在数学上是非常难求解的. 甚至目前可以认为是不可能的.</p><p>我之前对RSA的实现并不理解, 现在再来看, 莫名觉得超级合理, 算是意外的惊喜.</p><p>书中后半部分涉及到了椭圆曲线，当时看得时候也挺意外的, 觉得BlockChain的那些开拓者们, 真是牛逼, 用的技术都是很前沿的数学方面的研究成果. 这里就不展开写了, 毕竟对椭圆曲线, 我是一脸懵逼…..</p><p>书中还提到了很多伟大的科学家, 不仅限于数学家, 也提及了计算机领域的冯诺伊曼和密码学方面的阿兰图灵. 但是让我印象深刻的, 却是欧拉.</p><p>如果说音乐大师中, 无法绕开失聪后依然高产的贝多芬, 那么在科学领域里, 不得不提天赋型选手欧拉, 他在失明后的17年里, 依然以惊人的速度产出学术论文, 在他的那个时代, 其产量之多, 无人能及. 据说彼得堡科学院为了整理他的著作, 足足忙碌了47年.</p><p>1707年, 欧拉生于瑞士巴塞尔, 其父为牧师, 欧拉最初服从他父亲的意愿, 研究神学并从事神职工作. 当时盛产数学家的伯努利家族也在巴塞尔, 欧拉的一位朋友来自伯努利家族, 他发现了欧拉在数学方面展现出来的天赋, 因为朋友的极力劝说, 欧拉最终选择从事数学研究. </p><blockquote><p>欧拉有着令人难以置信的直觉和超人的记忆力，据说他能够在头脑中详细列出一大堆完整无缺的演算式而无须用笔写在纸上。在整个欧洲他被誉为“分析的化身”，法国科学院院士弗朗索瓦·阿拉戈说，“欧拉计算时就像人呼吸或者鹰乘风飞翔一样无需明显的努力.”</p></blockquote><p>就这样, 这位半路出道的少年全身心投入到了数学的研究中, 并在随后的人生里持续高产, 在数学界留下了浓墨重彩的一笔.</p><p>值得一提的是, 与历史上一些终身未婚的科学家(柏拉图, 牛顿)不同, 欧拉27岁时,  迎娶了一位美术老师, 婚后两人育有十多个儿女. 暮年时儿孙绕膝.</p><p>真妥妥人生赢家.</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>因为上海封城，我体验了一把上一辈人被饥荒支配的恐慌,  加之时不时满屏的负面消息, 搞得整个人一度情绪低落，没想到刷完这本书后, 内心竟平静了许多, 算是意外的收获.</p><p>书中提到20世纪的希尔伯特, 一位一生致力于建立一个相容的数学体系的践行者, 他为了激励后来的数学家们, 在自己的墓碑上铭刻了这么一段话:</p><blockquote><p>Wir nüsssen wissen,<br>Wir werden wissen.</p><p>我们必须知道,</p><p>我们将会知道.</p></blockquote><p>不由得肃然起敬.</p><p>致敬所有在追寻真理的路上勇于开拓的人们, 是你们, 给了人类终将知道的底气.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://book.douban.com/subject/1322358/">费马大定理</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%98%82%E5%93%88%E5%BE%B7%C2%B7%E6%AD%90%E6%8B%89">wiki 莱昂哈德·欧拉</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢这本书, 让我从封城的焦虑中，莫名其妙的平静了下来.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Variables</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-variables/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-variables/</id>
    <published>2022-03-08T08:20:21.000Z</published>
    <updated>2022-03-08T08:30:58.439Z</updated>
    
    <content type="html"><![CDATA[<p>时隔一个多月没更了, 这频率委实慢了些😄️</p><p>虽慢但不弃坑, 来继续填坑😉.</p><p>从这一节开始, 我们正式来学 VimScript 的语法知识啦.</p><p>先从变量开始. 来看下变量的声明, 赋值及作用域.</p><h4 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h4><p>VimScript 使用 let 来声明变量.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">let</span> foo=<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">:<span class="built_in">echo</span> foo</span><br><span class="line">:<span class="built_in">let</span> foo=2</span><br><span class="line">:<span class="built_in">echo</span> foo</span><br></pre></td></tr></table></figure><p>会分别输出:</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bar</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>之前我们提到 option, option 可以通过 <code>&amp;&#123;option&#125;</code> 来做为变量进行读写操作.</p><p>看个例子:</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> textwidth=80</span><br><span class="line">:echo <span class="comment">&amp;textwidth</span></span><br><span class="line">:let <span class="comment">&amp;textwidth = &amp;textwidth + 10</span></span><br><span class="line">:echo <span class="comment">&amp;textwidth</span></span><br><span class="line">:<span class="keyword">set</span> <span class="comment">textwidth?</span></span><br></pre></td></tr></table></figure><p>会依次输出:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">80</span><br><span class="line">90</span><br><span class="line"><span class="attribute">textwidth</span>=90</span><br></pre></td></tr></table></figure><p>这里也可以看出, 把 option 转为变量, 使用 let 来更新 option 的值, 比 <code>set option=&#123;value&#125;</code> 要灵活一些.</p><p>如果只想针对当前 Window 的 option 进行写操作而不修改全局的 option, 只需要给变量添加相应的 namespace 即可.[其实是变量的作用域, 待会会提到]</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:let &amp;l:textwidth</span> = 10</span><br><span class="line">:echo &amp;textwidth</span><br></pre></td></tr></table></figure><p>此时输出是10. [我们也可以使用<code>:setlocal textwidth = 10</code> 来设置 local textwidth]</p><p>开一个新的 Window, 继续输出:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:e</span> text.txt</span><br><span class="line"><span class="symbol">:echo</span> &amp;textwidth</span><br></pre></td></tr></table></figure><p>此时输出是 90.</p><p>说明刚刚针对 textwidth 的修改, 只对前一个 Window 有效.</p><p>[ 这里需要在不同的 Windows 下进行上面的操作, 因为同一个 Window 下的 buffers 共享相同的 option,  如果在同一个 Window 下的不同 buffer 中执行 <code>:echo &amp;textwidth </code> , 输出都是10.]</p><p>除了 option 外, registers 也可以作为变量来进行读写. 格式为 <code>@&#123;register&#125;</code></p><p>比如, 我们设置寄存器 a 的值为 hello.</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> <span class="meta">@a</span>=<span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>Normal 模式下, 在文件的任何位置, 按<code>&quot;ap</code>,  Vim 会把 寄存器 a 的值 hello, 粘贴在光标处.</p><p>也可以读取寄存器的值. 在文件中, 选中某个单词, 比如 world, 按 <code>y</code> 后, 在命令行执行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">echo</span> @<span class="comment">&quot;</span></span><br></pre></td></tr></table></figure><p>会输出 world.</p><p>使用<code>:help registers</code> , 可以查看所有可以读写的寄存器.</p><p>除了声明变量外, 当我们想要删除某个变量时, 可以使用 <code>unlet</code>.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:unlet</span> foo</span><br><span class="line"><span class="symbol">:echo</span> foo</span><br></pre></td></tr></table></figure><p>此时会输出错误信息:  Undefined variable: foo.</p><p>注意, unlet 不能用于 <code>&amp;&#123;option&#125;</code>, <code>@&#123;register&#125;</code>.</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在设置 local option 时, 我们已经提到了作用域.</p><p>现在以 buffer 为例, 我们来定义一个 buffer-variable:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:let b:hello</span> = &quot;world&quot;</span><br><span class="line"><span class="meta">:echo b:hello</span></span><br></pre></td></tr></table></figure><p>输出: world.</p><p>在另一个 buffer 中, 执行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">echo</span> <span class="variable">b:hello</span></span><br></pre></td></tr></table></figure><p>输出: Undefined variable: b:hello.</p><p>因为声明的 b:hello 只对前一个 buffer 有效.</p><p>可以通过 <code>:help internal-variables</code> , 来查看内部变量的 scope 列表.</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">|<span class="type">buffer</span>-variable|    <span class="type">b</span>:  <span class="keyword">Local</span> to the current buffer.</span><br><span class="line">|<span class="type">window</span>-variable|    <span class="type">w</span>:  <span class="keyword">Local</span> to the current window.</span><br><span class="line">|<span class="type">tabpage</span>-variable|   <span class="type">t</span>:  <span class="keyword">Local</span> to the current tab page.</span><br><span class="line">|<span class="type">global</span>-variable|    <span class="type">g</span>:  <span class="keyword">Global</span>.</span><br><span class="line">|<span class="type">local</span>-variable|     <span class="type">l</span>:  <span class="keyword">Local</span> to a function.</span><br><span class="line">|<span class="type">script</span>-variable|    <span class="type">s</span>:  <span class="keyword">Local</span> to a |<span class="type">:source</span>|<span class="type">&#x27;ed</span> Vim script.</span><br><span class="line">|<span class="type">function</span>-argument|  <span class="type">a</span>:  <span class="keyword">Function</span> argument (only inside a function).</span><br><span class="line">|<span class="type">vim</span>-variable|       <span class="type">v</span>:  <span class="keyword">Global</span>, predefined <span class="built_in">by</span> Vim.</span><br></pre></td></tr></table></figure><p>这里可以看出, 刚刚我们通过<code>&amp;l:textwidth=&#123;value&#125;</code> 设置了textwidth, 我们可以猜 Vim 中的 <code>&#123;option&#125;</code>, <code>&#123;option&#125;=</code> 本质上应该是个函数.</p><p>上述列表中的 script-variable,  function-argument 大量存在plugin中，随意选择一个Vim 插件，查看其源代码，就会看到<code>s:var</code>, <code>a:var</code> 的身影.</p><p>OK, 变量的介绍就到这啦, 下一篇来说说 if.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时隔一个多月没更了, 这频率委实慢了些😄️&lt;/p&gt;
&lt;p&gt;虽慢但不弃坑, 来继续填坑😉.&lt;/p&gt;
&lt;p&gt;从这一节开始, 我们正式来学 VimScript 的语法知识啦.&lt;/p&gt;
&lt;p&gt;先从变量开始. 来看下变量的声明, 赋值及作用域.&lt;/p&gt;
&lt;h4 id=&quot;声明与赋值
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>深入解析CID</title>
    <link href="http://lupeipei.github.io/posts/what-is-cid/"/>
    <id>http://lupeipei.github.io/posts/what-is-cid/</id>
    <published>2022-03-03T11:20:14.000Z</published>
    <updated>2022-03-03T11:43:10.896Z</updated>
    
    <content type="html"><![CDATA[<p>这是 IPFS 相关内容的第一篇, 打算花点时间把之前自己刷 <a href="https://proto.school/tutorials">ProtoSchool</a> 系列课程所学到的知识梳理下.</p><p>第一篇就从 CID 开始吧. </p><span id="more"></span> <p>当然, 又一次, 强烈推荐刷原文 ,妥妥真香系列.</p><h4 id="是什么与为什么"><a href="#是什么与为什么" class="headerlink" title="是什么与为什么"></a>是什么与为什么</h4><p>CID 是 Content Identifier 的缩写, 中文可以译成内容标识符.</p><p>CID是用来做什么的呢?    </p><p>我们知道, 网络中用于标识资源的方式是统一资源标识符URI(Uniform Resource Identifier). </p><p>URI主要有两种类型: URL(Uniform Resource Locator) 和 URN( Uniform Resource Name).</p><p>在Web2.0中,  我们最常用的是URL. 即统一资源定位符, 资源基于数据存储的位置来寻址. 这种标识资源的方式, 可以称之为 Location addressing.</p><p>比如一张图片的URL 为<code>https://www.puppies.com/cute_cat.jpg</code> .我们会预设, 这是一个有关小猫照片的URL. 访问该URL后, 会看到一张猫咪的萌照.</p><p>那么URLs这种标识资源的方式会有什么问题呢?</p><blockquote><p>最主要的就是安全问题.</p><p>我们无法通过一个URL, 来验证这个URL给到我们的是我们想要的内容. 比如上面的URL, 可能打开后, 不是一张猫咪的萌照, 而是一张小狗的照片, 甚至可能会是一个木马病毒.</p><p>也就是说, 托管在中心化网络上的文件, 它们的内容与它们基于位置的地址 URLs 是没有直接关系的. 我们不能通过URLs或者文件名来确定资源的内容.</p><p>另一个存在的问题是大量重复的资源文件存储在相同或者不同的服务器上. 用户看到的是不同的URLs, 但这些URLs 所标识的都是完全一样的资源文件, 这就造成空间上不必要的浪费.</p></blockquote><p>那么, 能否有一种基于文件内容的标识符呢? 我们能否从 location-based addressing 转向 content-based addressing?</p><blockquote><p>答案当然是Yes : P</p><p>在去中心化的网络中, 资源的标识就是基于内容的.</p><p>针对任意给定的资源文件, 我们可以通过特定的算法, 为其生成唯一的识别码. 即Content addressing. </p><p>这里要介绍的CID, 就是一种特殊形式的内容寻址. </p><p>这种基于内容的资源标识方式, 相比URLs, 除了更安全, 避免资源冗余外,  还有一个优势.</p><p>在中心化的网络中, 当我们基于某个URLs去获取数据时, 如果该服务点挂了, 那我们就无法获取到数据了, 但是在去中心化的网络中, 我们只要有所需要资源的内容地址, 比如CID, 就可以向全网的节点发送请求.</p></blockquote><p>了解了是什么和为什么后, 我们来看看CID具体是怎么生成的.</p><h4 id="基本构成及演进"><a href="#基本构成及演进" class="headerlink" title="基本构成及演进"></a>基本构成及演进</h4><p>CID 由IPFS 开发. 一个常见的CID 长这样:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">QmY<span class="number">7</span>Yh<span class="number">4</span>UquoXHLPF<span class="meta">o2</span>XbhXkhBvFoPwmQUSa<span class="number">92</span>px<span class="symbol">nxjQuPU</span></span><br></pre></td></tr></table></figure><p>CID的大致创建过程, 是使用一种加密算法(cryptographic algorithm)，将任意大小的输入（数据或文件）映射到固定大小的输出。这种对于输入数据的转换, 称为加密哈希摘要(cryptographic hash digest)。</p><p>IPFS目前大部分CID是使用  <code>sha2-256</code> 算法, 也就是 256 bits, 32bytes. </p><p>从这里也可以看出, CID的长度, 是由 <strong>cryptographic hash</strong> 加密哈希算法来决定的, 而跟文件本身的大小无关. 任意长度的输入通过相同的哈希函数进行处理, 会得到固定长度的输出.</p><p>但鉴于哈希算法可能会被证明是不安全的,  比如 sha1 , 所以CID需要支持多种哈希算法.</p><p>既然要支持多种加密算法，那我们怎么知道这个特定的哈希值是使用哪种算法生成的呢?</p><p>CID 使用 multihash 来标识所用的加密算法.</p><p>具体就是<strong>将长度和使用的算法, 作为Hash值的唯一识别前缀</strong>.</p><h5 id="Multihash"><a href="#Multihash" class="headerlink" title="Multihash"></a>Multihash</h5><p>Multihash 遵循 TLV 模式, 即 <strong>T</strong>ype, <strong>L</strong>ength, <strong>V</strong>alue:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L02-multihash.jpeg"></p><p>Type</p><blockquote><p>标识所使用的加密算法 cryptographic algorithm. </p><p>通过 <a href="https://github.com/multiformats/multicodec/blob/master/table.csv">multicodec table</a> 可以查看对应的算法, 比如, <code>sha2-256</code>  的code 为 18, 用16进制表示则是 <code>0x12</code> </p></blockquote><p>Length</p><blockquote><p> 长度, 如果用的是<code>sha2-256</code> 算法, 则是32 bytes</p></blockquote><p>Value</p><blockquote><p>生成的哈希值</p></blockquote><p>当我们通过加密哈希摘要得到一个固定大小的输出时, 这个输出是二进制格式的. 对受众来说, 不是那么友好, 因此需要将其编码成字符串, 用字符串表示CID.</p><p>IPFS 最初是使用 base58btc 将二进制格式的哈希值, 进行编码压缩, 得到类似这样的结果:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">QmY<span class="number">7</span>Yh<span class="number">4</span>UquoXHLPF<span class="meta">o2</span>XbhXkhBvFoPwmQUSa<span class="number">92</span>px<span class="symbol">nxjQuPU</span></span><br></pre></td></tr></table></figure><p>以 Qm开头, 这也就是第一代CID v0.</p><p>但随之问题也就来了.</p><ul><li><p>我们如何得知程序是用什么方法对原数据本身进行了编码? 我们知道文件内保存数据的形式是二进制, 将二进制数据序列化用的是 protobuf 还是JSON, 抑或是其他 ？</p></li><li><p>我们如何得知程序是用什么方法来创建CID的字符串表示的? CIDv0 版本使用了 base58btc , 但是如果我们想要使用 base32 或者 base64 怎么办呢?</p></li></ul><p>为了解决这两个问题, CID不得不演进, 由此, CIDv1应运而生.</p><p>针对第一个问题,  CIDv1 引入了另外的前缀, 用来标识针对文件数据所使用的编码方式. 也就是 Multicodec Prefix.</p><p>这样, 我们的CID 就扩展成了这样:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L03-multicodec.png"></p><p>这里 Multicodec Prefix 的值是 01110000, 即 0x70, 查看<a href="https://github.com/multiformats/multicodec/blob/master/table.csv">codec identifier table</a>, 对应的就是 dag-pb. </p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images20220303145823.png"></p><p>dag-pb 表示 MerkleDAG protobuf, 是 <a href="https://ipld.io/">IPLD</a> (<strong>I</strong>nter<strong>P</strong>lanetary <strong>L</strong>inked <strong>D</strong>ata)的一种. [不懂 IPLD? 没事, 我暂时也没整明白, 先把 dag-pb 当作是一种特殊的 protobuf 看待, 不影响整体理解]</p><p>为了区分版本, CIDv1 还添加了 version prefix.</p><p>所以整个 CID 的构成就变成这样:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;cid-version&gt;</span><span class="section">&lt;multicodec&gt;</span><span class="section">&lt;multihash-algorithm&gt;</span><span class="section">&lt;multihash-length&gt;</span><span class="section">&lt;multihash-hash&gt;</span></span><br></pre></td></tr></table></figure><p>其中, cid-version 表示CID的版本.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L04-version-prefix.png"></p><p>针对第二个问题, 我们已经知道, CIDv0 中, 默认使用base58btc.</p><p>那么在CIDv1及之后的版本中, 如果我们使用了其他的编码方式, 如何让他人知道你使用的是哪种编码方法呢?</p><p>大概你也猜到了, 继续用前缀. [不得不叹一句: 前缀大法好]</p><p>Multibase prefix 就是用来表示在字符串和二进制格式之间转换CID时所使用的基础编码。</p><p>与前面Multicodec prefix 不同的是,  它不是放在二进制格式的输出结果中, 而是放在了转换后的字符串中.</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesT0006L05-multibase-prefix.png"></p><p>来看两个字符串格式的CID:</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR</span></span><br><span class="line">bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi</span><br></pre></td></tr></table></figure><p>我们知道第一个CID是CIDv0, 因为它以Qm开头, 第二个以b开头, 表示编码方法为 base32.</p><p>通过查看完整的 <a href="https://github.com/multiformats/multibase/blob/master/multibase.csv">multibase</a> 表, 可以知道CID具体所采用的基础编码方法.</p><p>至此, 我们基本把CID的构成和演进理得差不多了.</p><p>如果你本地安装了ipfs,  通过命令行, 可以查看CID 的相关内容, 比如支持的base encoding:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs cid bases</span><br></pre></td></tr></table></figure><p>支持的 Cryptographic hashing  算法:</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ipfs cid hashes</span></span><br></pre></td></tr></table></figure><p>目前ipfs (0.11.0) 的CID, 依然默认是 v0 版本.</p><h4 id="在线解析"><a href="#在线解析" class="headerlink" title="在线解析"></a>在线解析</h4><p>考虑到CID的构成复杂,  IPFS提供了<a href="https://cid.ipfs.io/">CID inspector</a> 来帮助我们解析CID结果. </p><p>以 QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR 为例:</p><p>结果如下:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesimage-20220205151801443.png"></p><p>这里我们可以分别看到 multibase, version, muticodec, multihash对应的值.</p><p>稍稍提一下, 因为 multibase和 muticodec 是CIDv1后提出的, 而我们的CID 是v0版本的,  所以解析后, 这两部分显示了 implicit.</p><p>我们将解析后得到的CIDv1, 继续解析, 得到如下的结果:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagesXnip2022-02-05_15-21-18.jpg"></p><p>此时, 我们看到multibase 为base32.</p><p>不管是 v0 还是 v1 的CID, 它们的摘要值都是C3C4…31DE94391A, 表示着同一份文件.</p><p>OK, 基本算是缕得差不多了, CID的内容就先到这啦.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI  wiki</a></p><p><a href="https://github.com/ipfs/go-ipfs">go-ipfs</a></p><p><a href="https://proto.school/anatomy-of-a-cid">Anatomy of a CID</a></p><p><a href="https://proto.school/content-addressing">content addressing</a></p><p><a href="https://github.com/multiformats/multicodec">multicodec</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 IPFS 相关内容的第一篇, 打算花点时间把之前自己刷 &lt;a href=&quot;https://proto.school/tutorials&quot;&gt;ProtoSchool&lt;/a&gt; 系列课程所学到的知识梳理下.&lt;/p&gt;
&lt;p&gt;第一篇就从 CID 开始吧. &lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="IPFS" scheme="http://lupeipei.github.io/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>Traefik 改用 acme.sh 为域名生成证书</title>
    <link href="http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/"/>
    <id>http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/</id>
    <published>2022-02-23T10:21:58.000Z</published>
    <updated>2022-02-23T10:40:47.471Z</updated>
    
    <content type="html"><![CDATA[<p>Traefik 踩坑记录.</p><span id="more"></span> <p>Traefik 可以配置自动生成证书的 ACME 供应商, 比如Let’s Encrypt.</p><p>官方文档提到会自动更新证书. 但实际情况是, 到期了证书有时并没有更新, 导致出现证书过期的情况. </p><p>这里记录下在服务器上配置 Traefik 时, 改用 acme.sh 来签证书并自动更新的步骤. </p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>默认服务器为Ubuntu, traefik 已启用, 对应的docker-compose.yml 存放在/opt/global目录下.</p><p>其中<code>/opt/global/docker-compose.yml</code> 的具体内容如下.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们挂载了/opt/global 目录下的 <code>traefik.toml</code>, 该文件存放了一些默认的配置, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">entryPoints</span>]</span><br><span class="line">  [<span class="string">entryPoints.web</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:80&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.websecure</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:443&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.traefik</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:8080&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">api</span>]</span><br><span class="line">  <span class="string">insecure</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">dashboard</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[<span class="string">log</span>]</span><br><span class="line">  <span class="string">level=</span> <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">certificatesResolvers</span>]</span><br><span class="line">  [<span class="string">certificatesResolvers.lets-encrypt</span>]</span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme</span>]</span><br><span class="line">      <span class="string">email</span> <span class="string">=</span> <span class="string">&quot;myEmail@gmail.com&quot;</span></span><br><span class="line">      <span class="string">storage</span> <span class="string">=</span> <span class="string">&quot;acme.json&quot;</span></span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme.tlsChallenge</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">providers.docker</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">exposedByDefault=false</span></span><br><span class="line">  <span class="string">network</span> <span class="string">=</span> <span class="string">&quot;my_proxy&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">providers.file</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">directory=&quot;/providers&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到我们声明了一个证书解析器 (certificatesResolvers)  lets-encrypt. </p><p>而 我们需要使用 acme.sh 生成证书的 Web项目, 存放在/opt/web/ 下, 其 <code>docker-compose.yml</code> 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.entrypoints=web&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.middlewares=my-web-https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.middlewares.my-web-https.redirectscheme.scheme=https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.certresolver=lets-encrypt&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里可以看到, 我们给 web 配置的 certresolver 配置为之前定义的 lets-encrypt. </p><p> 如果查看 <code>acme.json</code> 文件, 你会看到类似如下内容, Certificates 部分有我们的 <code>example.com</code> 及子域名<code>api.example.com</code>  :</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lets-encrypt&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Account&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Email&quot;</span>: <span class="string">&quot;myEmail@gmail.com&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Registration&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;valid&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;contact&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;mailto:myEmail@gmail.com&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;https://acme-v02.api.letsencrypt.org/acme/acct/xxxxx&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;PrivateKey&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;KeyType&quot;</span>: <span class="string">&quot;4096&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Certificates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example.com&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sans&quot;</span>: [<span class="string">&quot;api.example.com&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example1.com&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      .........</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时, 网站正常访问.</p><p>现在我们来更改 <code>example.com</code> 的 tls 配置, 证书改用 acme.sh 来签发.</p><h4 id="改用-acme-sh"><a href="#改用-acme-sh" class="headerlink" title="改用 acme.sh"></a>改用 acme.sh</h4><p>acme 验证的主要方式是 standalone 和 webroot.</p><p>鉴于 standalone 需要占用80或者443端口, 导致需要暂停服务器,这里我们使用 webroot 方式来验证域名.</p><p> webroot 模式下, acme 会在网站根目录下生成一个临时子目录 <code>.well-known/acme-challenge</code>，然后服务器会向这个路径发请求，如果请求成功，则验证通过, 随后会删除掉这个临时目录. </p><p>我们将根目录web root 默认为 /var/www, 同时在当前目录下, 新增两个文件夹, 用来分别挂载 /var/www 和 /acme.sh 目录.</p><p>/opt/global/ 目录下, 新建文件 <code>docker-compose.acme.sh.yml</code>, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">acme.sh:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">neilpang/acme.sh:3.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">acme.sh</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/var/www</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">daemon</span></span><br></pre></td></tr></table></figure><p>新增文件夹:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir nginx acme.sh</span><br></pre></td></tr></table></figure><p>生成的证书会存放在acme.sh 目录中, 而 nginx 目录用于验证域名.</p><p>这里我们起一个nginx 服务, 使得 traefik 将所有匹配 <code>/.well-known</code> 的路径请求都转发到这个nginx 上. 同时, 将当前目录下的 nginx 目录挂载到 nginx 服务的静态文件默认地址 <code>/usr/share/nginx/html</code> . </p><p>这样, 当使用 webroot 模式验证域名时, acme.sh 就会在 <code>/opt/global/nginx</code> 目录下,生成临时子目录 <code>.well-known/acme-challenge</code>, 而验证时, 访问 <code>/usr/share/nginx/html</code>, 也就是访问我们的 <code>/opt/global/nginx</code> 目录.</p><p>我们新增文件 <code>/opt/global/docker-compose.nginx.yml</code> , 添加如下内容:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.rule=HostRegexp(`&#123;catch_all:.*&#125;`) &amp;&amp; PathPrefix(`/.well-known`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.priority=999&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.global-nginx.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里有一点需要提一下.</p><p>我们给 nginx 服务配置 traefik 时,  设置了priority的值为999. 默认情况下,  traefik 中路径的 priority是根据rule的长度来决定的. 这里我们希望所有带有 <code>/.well-known</code> 的请求都转发到这个 nginx 上, 所以手动设置了999.</p><p>启动 nginx:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.nginx.yml up -d</span><br></pre></td></tr></table></figure><p>nginx 启动后, 我们启动 acme.sh.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.acme.sh.yml up -d</span><br></pre></td></tr></table></figure><p>开始签证书啦.</p><p>第一次使用acme.sh时, 需要注册用户邮箱:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it acme.sh sh -l</span><br><span class="line">acme.sh --register-account -m myEmail@gmail.com</span><br><span class="line">acme.sh --issue -d example.com -d api.example.com --webroot /var/www</span><br></pre></td></tr></table></figure><p>正常情况下, 会一切顺利. 默认CA是ZeroSSL.com</p><p>如果 acme.sh 签发证书时 Timeout了, 请设置代理. </p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><p>证书签发成功后, 我们查看 <code>/opt/global/acme.sh/example.com</code> 目录, 会看到刚刚生成的证书.</p><p>现在, 我们把新鲜出炉的证书用起来.</p><p>修改 <code>/opt/global/docker-compose.yml</code> , 将 <code>/opt/global/acme.sh</code> 目录挂载到 traefik 中:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br></pre></td></tr></table></figure><p>然后我们在traefik 的动态配置中把证书放进去.</p><p>在 <code>/opt/global/providers</code> 目录下, 新增 <code>example_com_certs.toml</code> 文件, 写入我们的证书路径:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[tls.certificates]]</span></span><br><span class="line">  <span class="attr">certFile</span> = <span class="string">&quot;/acme.sh/example.com/fullchain.cer&quot;</span></span><br><span class="line">  <span class="attr">keyFile</span> = <span class="string">&quot;/acme.sh/example.com/example.com.key&quot;</span></span><br></pre></td></tr></table></figure><p>同时, 我们需要将 <code>/opt/global/acme.json</code> 文件中 Certificates 部分, 有关 example.com 的证书内容删除.</p><p>最后, 修改 <code>/opt/web/docker-compose.yml</code>, 把tls 部分的配置, 改为options=default.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.options=default&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br></pre></td></tr></table></figure><p>重启 traefik.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart traefik</span><br></pre></td></tr></table></figure><p>再次请求 <a href="https://example.com/">https://example.com</a>, 会发现证书已经签成由ZeroSSL 颁发的证书. </p><p>替换完成. 撒花! 🥳</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://doc.traefik.io/traefik/">traefik doc</a></p><p><a href="https://doc.traefik.io/traefik/https/acme/">traefick: let’s Encrypt</a></p><p><a href="https://github.com/acmesh-official/acme.sh">acme.sh</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traefik 踩坑记录.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Acme" scheme="http://lupeipei.github.io/tags/Acme/"/>
    
      <category term="Traefik" scheme="http://lupeipei.github.io/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>Using Puppeteer with executablePath in Electron</title>
    <link href="http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/"/>
    <id>http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/</id>
    <published>2022-02-15T08:31:40.000Z</published>
    <updated>2022-02-22T06:37:44.224Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Electron 踩坑过程.</p><span id="more"></span> <h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用 Electron 创建桌面应用, 程序中调用了 <a href="https://github.com/puppeteer/puppeteer">puppeteer</a>,  开发环境下一切正常, 使用 electron-builder 在Mac上打包成 Windows下的可执行文件后, 程序在Windows上跑时一直卡着不动.</p><p>Debug后发现一直卡在 <code>puppeteer.launch</code> .</p><p>环境:</p><p>puppeteer: 13.0.1</p><p>electron: 17.0.0</p><p>electron-builder: 22.10.4</p><p>node: 12.22.3</p><p>yarn: 1.22.10</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>Debug后发现问题的根源在于 MacOS 上打包时,  node_module 中 puppeteer 的Chrome, 是适配MacOS系统版本的, 这个Chrome 在 Windows下肯定是无法正常运行的.</p><p>参考<a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a> 中, scriptify 的回复:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagespuppeteer.jpg"></p><p>自己写一个脚本, 本地下载个Windows版本的chrome, 然后打包进去, <code>puppeteer.launch</code> 时指定 executablePath.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载 chrome.</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browserFetcher = puppeteer.createBrowserFetcher(&#123; <span class="attr">platform</span>: <span class="string">&quot;win32&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> revisionInfo = <span class="keyword">await</span> browserFetcher.download(<span class="string">&#x27;533271&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(revisionInfo)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>按照 scriptify 给的方法, 修改package.json:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;asar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;asarUnpack&quot;</span>: <span class="string">&quot;node_modules/puppeteer/.local-chromium/win32-533271/**/*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用 <code>puppeteer.launch</code> 的地方:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> homeDir = puppeteer.executablePath().split(<span class="string">&#x27;app.asar&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> executablePath = homeDir.concat(<span class="string">&quot;app.asar.unpacked\\node_modules\\puppeteer\\.local-chromium\\win32-533271\\chrome-win32\\chrome.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: executablePath, <span class="attr">args</span>: [ <span class="string">&quot;--disable-gpu&quot;</span>, <span class="string">&quot;--disable-dev-shm-usage&quot;</span>, <span class="string">&quot;--disable-setuid-sandbox&quot;</span>, <span class="string">&quot;--no-sandbox&quot;</span> ] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>诡异的是, 打包后扔进 Windows里面运行, 发现 Chrome.exe 文件是存在的. 但是 puppeteer 依然没有成功运行.</p><p>最后无奈, 直接换成 在Windows下打包, 同时指定 executablePath.问题解决.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a></p><p><a href="https://yrq110.me/post/front-end/the-right-way-to-use-puppeteer-in-electron/">配置Electron中Puppeteer executablePath的正确姿势</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Electron 踩坑过程.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>As I began to love myself</title>
    <link href="http://lupeipei.github.io/posts/as-I-began-to-love-myself/"/>
    <id>http://lupeipei.github.io/posts/as-I-began-to-love-myself/</id>
    <published>2022-02-13T13:53:12.000Z</published>
    <updated>2022-04-26T08:14:18.568Z</updated>
    
    <content type="html"><![CDATA[<p>读到一首不错的现代诗, 分享下 ^_^</p><span id="more"></span><p>As I began to love myself,<br>I found that anguish and emotional suffering are only warning signs that I was living against my own truth.<br>Today, I know, this is “authenticity”.</p><p>As I began to love myself,<br>I understood how much it can offend somebody,<br>As I try to force my desires on this person, even though I knew the time was not right and the person was not ready for it, and even though this person was me.<br>Today I call it “respect”.</p><p>As I began to love myself,<br>I stopped craving for a different life, and I could see that everything that surrounded me was inviting me to grow.<br>Today I call it “maturity”.</p><p>As I began to love myself,<br>I understood that at any circumstance, I am in the right place at the right time, and everything happens at the exactly right moment.<br>So I could be calm.<br>Today I call it “self-confidence”.</p><p>As I began to love myself,<br>I quit steeling my own time, and I stopped designing huge projects for the future.<br>Today, I only do what brings me joy and happiness, things I love to do and that make my heart cheer, and I do them in my own way and in my own rhythm.<br>Today I call it “simplicity”.</p><p>As I began to love myself,<br>I freed myself of anything that is no good for my health – food, people, things, situations, and everything that drew me down and away from myself.<br>At first I called this attitude a healthy egoism.<br>Today I know it is “love of oneself”.</p><p>As I began to love myself,<br>I quit trying to always be right, and ever since I was wrong less of the time.<br>Today I discovered that is “modesty”.</p><p>As I began to love myself,<br>I refused to go on living in the past and worry about the future.<br>Now, I only live for the moment, where everything is happening.<br>Today I live each day, day by day, and I call it “fulfillment”.</p><p>As I began to love myself,<br>I recognized that my mind can disturb me and it can make me sick.<br>But as I connected it to my heart, my mind became a valuable ally.<br>Today I call this connection “wisdom of the heart”.</p><p>We no longer need to fear arguments, confrontations or any kind of problems with ourselves or others.<br>Even stars collide, and out of their crashing new worlds are born.<br>Today I know “that is life”.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读到一首不错的现代诗, 分享下 ^_^&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
      <category term="Poem" scheme="http://lupeipei.github.io/tags/Poem/"/>
    
  </entry>
  
  <entry>
    <title>electron 代理配置</title>
    <link href="http://lupeipei.github.io/posts/set-proxy-for-electron/"/>
    <id>http://lupeipei.github.io/posts/set-proxy-for-electron/</id>
    <published>2022-02-07T12:10:53.000Z</published>
    <updated>2022-02-07T12:27:02.284Z</updated>
    
    <content type="html"><![CDATA[<p>踩了两次坑, 记录下.</p><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>node version: v12.22.3<br>yarn version: 1.22.10</p><p>终端执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>一直报错:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Output:</span></span><br><span class="line"><span class="symbol">RequestError:</span> read ETIMEDOUT</span><br></pre></td></tr></table></figure><p>已经设置了代理, 无效:</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">http_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">all_proxy=socks5:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7891</span></span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>参考 <a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a>, node 10+需要设置环境变量.<br><code>GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE</code> 采用默认值<code>GLOBAL_AGENT_</code></p><p>分别设置 <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTP_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTPS_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ELECTRON_GET_USE_PROXY</span>=1</span><br></pre></td></tr></table></figure><p>重新执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>OK.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;踩了两次坑, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Operator Pending Mappings</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/</id>
    <published>2022-01-13T13:37:12.000Z</published>
    <updated>2022-01-13T13:41:55.207Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. </p><p>官方文档中, 对 Operator-pending mappings 的解释是:</p><blockquote><p>Operator-pending mappings can be used to define a movement command that can be<br>used with any operator. </p></blockquote><p>Operator-pending mappings 可以用于定义会被执行的移动指令.[我这翻译的…]</p><p>看个简单的例子来理解.</p><p>打开文件test.txt, 内容如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> (<span class="keyword">some</span>) <span class="built_in">text</span> <span class="keyword">about</span> topic one.</span><br><span class="line"></span><br><span class="line">It has multiple (<span class="built_in">paragraphs</span>).</span><br><span class="line">part1(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part2(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part3(<span class="built_in">paragraph</span>) content.</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>命令模式下, 执行:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">onoremap</span> <span class="selector-tag">p</span> <span class="selector-tag">i</span>(</span><br></pre></td></tr></table></figure><p>这时, 在 normal 模式下, 按<code>dp</code>, 等同于<code>di(</code>, 即删除<code>()</code> 里的内容.</p><p>这里默认从当前光标所在位置, 往下查找第一个<code>()</code>, 然后执行操作.</p><p>比如, 我们把光标移动到第三行 It has……, 按<code>dp</code>,  会发现 paragraphs 被删除了.</p><p>当光标停留在最后一行 end, 按<code>dp</code>, 发现无效.</p><p>如果想要消除光标所在位置, 就需要使用<code>&lt;C-u&gt;</code> CTRL-u.</p><p>来看个例子:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:onoremap i( :&lt;C-u&gt;normal!</span> 0f)vi(&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>此时, 按<code>di(</code>, 不管光标在哪里, 会删除光标所在行的第一个<code>()</code> 中的内容.</p><p>鉴于 Operator-pending mappings 我平时用到的很少, 也没有细细研究, 目前就不多扯了.</p><p>想要了解更多, 可以看官方文档:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">:h omap-<span class="meta">info</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. &lt;/p&gt;
&lt;p&gt;官方文档中, 对 Operator-pending mappings 的解释是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Operator-pending map
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>status lines</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-statusline/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-statusline/</id>
    <published>2022-01-10T07:48:42.000Z</published>
    <updated>2022-01-10T07:54:21.359Z</updated>
    
    <content type="html"><![CDATA[<p>来看看如何自定义状态栏显示.</p><p>Statusline 是 Vim 的一个 option, 可通过:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>查看当前的 statusline 配置.</p><p>当然, 我们也可以自定义状态栏的显示内容.</p><p>打开一个Markdown 文件,  命令行模式下, 输入:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=%f\ -\ FileType:\</span> %y</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo<span class="selector-class">.md</span> - FileType: <span class="selector-attr">[markdown]</span></span><br></pre></td></tr></table></figure><p>这里的 <code>%f</code>表示当前文件的相对路径, <code>%y </code> 表示文件的类型.</p><p>statusline 的设置, 有些类似 C 里面的 printf.</p><p>它的通用格式如下:</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">%-0</span><span class="template-variable">&#123;minwid&#125;</span><span class="xml">.</span><span class="template-variable">&#123;maxwid&#125;</span><span class="template-variable">&#123;item&#125;</span></span><br></pre></td></tr></table></figure><p>其中, 除了<code>%</code>  和 <code>&#123;item&#125;</code>, 其他都是可选的. 而 minwd, maxwid 分别指的是最小和最大宽度.</p><p>看几个简单的例子就清楚了.</p><p>显示行号:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %4l\ Total:\ %4L</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>:    <span class="number">9</span> Total:   <span class="number">66</span></span><br></pre></td></tr></table></figure><p>这里设置了最短长度4, 默认用空格来补全.</p><p>可以设置为用0来补全:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %04l\ Total:\ %04L</span><br></pre></td></tr></table></figure><p>状态栏显示如下:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>: <span class="number">0009</span> Total: <span class="number">0066</span></span><br></pre></td></tr></table></figure><p>再比如, 显示文件的绝对路径:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> <span class="attribute">statusline</span>=%.20F</span><br></pre></td></tr></table></figure><p>此处, 最大宽度设置为20, 状态栏显示如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;-<span class="keyword">on</span>-buffer-<span class="keyword">local</span>.md</span><br></pre></td></tr></table></figure><p>通过 <code>:h statusline</code> , 可以查看所有可用的 item 及其对应含义.</p><p>此外, 如果 statusline 是以 <code>%!</code> 开头, 比如 <code>:set statusline=%!MyStatusLine()</code> , 则表示<code>MyStatusLine()</code> 是个表达式, 这个表达式的结果才是 statusline 对应的值.</p><p>如果你安装了airline, 命令模式输入:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>会看到输出结果:</p><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line">statusline=%!airline<span class="function"><span class="keyword">#</span><span class="title">statusline</span><span class="params">(1)</span></span></span><br></pre></td></tr></table></figure><p>这里就是使用了<code>%!</code>.</p><p>书中还介绍了<code>%=</code>, 用于对齐, 这里就略过了.</p><p>OK, 本节结束, 我去吃点好吃的奖励下自己还没弃坑😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来看看如何自定义状态栏显示.&lt;/p&gt;
&lt;p&gt;Statusline 是 Vim 的一个 option, 可通过:&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>autocmd</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/</id>
    <published>2021-12-31T09:31:55.000Z</published>
    <updated>2022-01-10T07:48:31.210Z</updated>
    
    <content type="html"><![CDATA[<p>autocmd 用于配置当某个确定事件发生时, 要执行的命令.</p><p>借用书中的例子, 看一下 autocmd 的基本结构:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:autocmd BufWritePre,BufRead *.html :normal</span> gg=G</span><br><span class="line"><span class="code">         ^                   ^      ^</span></span><br><span class="line"><span class="code">         |                   |      |</span></span><br><span class="line"><span class="code">         |                   |      需要执行的命令</span></span><br><span class="line"><span class="code">         |                   |</span></span><br><span class="line"><span class="code">         |                   模式, 用来过滤事件</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="code">         监听的事件</span></span><br></pre></td></tr></table></figure><p>这里 BufWritePre, BufRead 都是需要监听的事件, *.html 是需要过滤的模式, 整个命令的含义就是, 当开始写入 html 类型文件或者编辑 html 类型文件之前, 自动执行<code>:normal gg=G</code>, 也就是缩进代码.</p><p>[此处, BufWritePre 指的是开始将整个 Buffer 写入文件 , BufRead 指的是读文件后, 开始编辑. ]</p><p>通过<code>:h autocmd-events</code> 可以查看所有可以绑定 Autocommands 的事件列表.</p><p>其中, 最常用的 Event 是 FileType.</p><p>比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">autocmd</span> FileType javascript <span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;LocalLeader&gt;</span><span class="keyword">c</span> I//<span class="symbol">&lt;esc&gt;</span></span><br></pre></td></tr></table></figure><p>当打开一个javascript (.js)文件时, 执行<code>nnoremap &lt;buffer&gt; &lt;LocalLeader&gt;c I//&lt;esc&gt;</code>, 也就是按 <code>&lt;LocalLeader&gt;c</code>  会添加注释.</p><p>这里提一个简单的应用.</p><p>Vim中编辑 json 文件的时候, 默认是没有格式化的, 如何实现打开JSON文件时, 自动格式化内容, 方便阅读?</p><p>这里说一下我的做法.</p><p>安装 jq, 附上链接<a href="https://stedolan.github.io/jq/download/">download</a></p><p>修改 <code>.vimrc </code>, 添加:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">autocmd <span class="keyword">BufRead </span>*.<span class="keyword">json </span>%!<span class="keyword">jq </span><span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure><p>source 后, 打开 json 格式文件时, 可以看到已经格式化了.</p><p>autocmd 有一个兄弟 augroup. 可以把相近的 autocmd 放在一个group 中:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">augroup</span> testgroup</span><br><span class="line">  autocmd!</span><br><span class="line">  <span class="keyword">autocmd</span> BufWrite * :<span class="keyword">echom</span> <span class="string">&quot;Cats&quot;</span></span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p>这里使用<code>autocmd!</code>  来清理之前的 autocmd 设置.</p><p>augroup 的作用, 是用来避免重复定义 autocmd. 官网文档给到的解释是:</p><blockquote><p>This prevents having the autocommands defined twice (e.g., after sourcing the .vimrc file again).</p></blockquote><p>书中使用了一个 BufWrite + echom 的例子来说明使用 augroup 可以避免的问题, 同文档提到的一致, 这里就不细说了.</p><p>附上一个小小的tips. 如果你有执行 augroup 的例子, 会发现 messages 有些多,  想要清理的话, 可以使用<code>:messages clear</code></p><p>OK, 本章结束.</p><p>Bye 2021.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;autocmd 用于配置当某个确定事件发生时, 要执行的命令.&lt;/p&gt;
&lt;p&gt;借用书中的例子, 看一下 autocmd 的基本结构:&lt;/p&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>hexo 主题魔改记录</title>
    <link href="http://lupeipei.github.io/posts/custom-hexo-next-theme/"/>
    <id>http://lupeipei.github.io/posts/custom-hexo-next-theme/</id>
    <published>2021-12-28T13:32:58.000Z</published>
    <updated>2021-12-28T13:39:12.493Z</updated>
    
    <content type="html"><![CDATA[<p>自己折腾了下 Hexo 的 next 主题. 给 post 添加了字段 type. 为了避免下次崩了的时候, 我会对着自己写的代码一脸懵逼, 简单记录下……</p><span id="more"></span><p>本文基于 hexo-theme-next version 5.</p><h4 id="首页分页"><a href="#首页分页" class="headerlink" title="首页分页"></a>首页分页</h4><p>预期效果: 在首页不显示 post 中 type 为 book 的文章</p><p>思路: 修改首页的分页, 过滤掉 type 为 book 的文章.</p><p>具体实现:</p><p>参考 <a href="https://github.com/hexojs/hexo-generator-index">hexo-generator-index</a> ,  在 next 的 scripts 下, 添加文件 customIndexPagination.js, 内容如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.extend.generator.register(<span class="string">&#x27;customIndexPagination&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  locals.posts.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  set post default type as post, 设置默认值</span></span><br><span class="line">    <span class="keyword">if</span> (post.type == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      post.type = <span class="string">&quot;post&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">const</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">  <span class="comment">// filter posts with type == &quot;post&quot;, 过滤</span></span><br><span class="line">  <span class="keyword">const</span> postsWithoutbook = posts.find(&#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;post&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">  posts.data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (b.sticky || <span class="number">0</span>) - (a.sticky || <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> path = config.index_generator.path || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(path, postsWithoutbook, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h4><p>预期效果: 同一个 category 中, 所有 type 为 book 的 post 按照指定字段排序后再分页.这里按照 ranked 字段来排序 posts.</p><p>思路: 找到 page下对应的category, 按照 ranked 字段排序后, 调用 slice 实现分页.</p><p>具体实现:</p><p>next version 5 的模板用的是swig 语法, <a href="https://github.com/paularmstrong/swig">swig</a>已经多年不维护, 这个用起来还是折腾的.很多ES6语法不支持. 等后续有时间再折腾, 目前凑合用用swig….</p><p>修改 layout/category.swig, 在 Section部分, 添加如下代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;section id=&quot;posts&quot; class=&quot;posts-collapse&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class="line">    &lt;h2 &gt;&#123;&#123; page.category &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">...........</span><br><span class="line"></span><br><span class="line">  &#123;% set current = page.current %&#125;</span><br><span class="line">  &#123;% set pre = current - 1 %&#125;</span><br><span class="line">  &#123;% set perPage = config.per_page %&#125;</span><br><span class="line">  &#123;% set category = site.categories.findOne(&#123; &quot;name&quot;: page.category &#125;) %&#125;</span><br><span class="line">  &#123;% set posts = category.posts.sort(&#x27;ranked&#x27;) %&#125;</span><br><span class="line">  &#123;% set bookPost = posts.find(&#123; type: &#x27;book&#x27; &#125;) %&#125;</span><br><span class="line">  &#123;% set hasBookPost = bookPost.length &gt; 0 %&#125;</span><br><span class="line">  &#123;% if hasBookPost %&#125;</span><br><span class="line">    &#123;% set posts = posts.slice(perPage * pre, perPage * current) %&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;% set posts = page.posts %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">    &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">  ..........</span><br></pre></td></tr></table></figure><p>逻辑很简单, 主要调用 slice 来得到当前分页中的posts.</p><p>其中 site.categories 调用了findOne来查找当前页面的category, 参考的是 <a href="https://hexojs.github.io/warehouse/index.html">warehouse</a>.</p><p>OK.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/hexojs/hexo-pagination">hexo-pagination</a></p><p><a href="https://github.com/hexojs/hexo-generator-index">hexo-generator-index</a></p><p><a href="https://hexojs.github.io/warehouse/index.html">warehouse</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己折腾了下 Hexo 的 next 主题. 给 post 添加了字段 type. 为了避免下次崩了的时候, 我会对着自己写的代码一脸懵逼, 简单记录下……&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Hexo" scheme="http://lupeipei.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Buffer-Local</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-buffer-local/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-buffer-local/</id>
    <published>2021-12-28T01:34:51.000Z</published>
    <updated>2021-12-28T08:07:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>这一章的内容结合了前面学到的知识.</p><p>Buffer-Local, 顾名思义, 基于 Buffer,  只针对当前 Buffer 有效.</p><p>前面遇到的 mappings, options , abbreviations, 当需要只对当前 Buffer 生效时, 命令分别是什么呢?</p><p>来逐个说明下.</p><ul><li><p>mappings</p><p>打开任意文件, 在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">x</span> dd</span><br></pre></td></tr></table></figure><p>normal 模式下, 按<code>&lt;Leader&gt;x</code>, 等同于dd, 删除当前行.</p><p>此时, 另开一个文件, 执行同样的操作, 按<code>&lt;Leader&gt;x</code> , 没有变化.</p><p>Buffer-Local mappings 跟通用的 mappings 不一样的地方, 就是多了一个<code>&lt;buffer&gt;</code>, 也很好记.</p><p>需要稍稍注意的是, 当 buffer 与<code>&lt;Leader&gt;</code> 结合时, 建议使用 <code>&lt;LocalLeader&gt;</code> 来代替 <code>&lt;Leader&gt;</code>, 这样避免覆盖了他人的 <code>&lt;leader&gt;</code> mapping.</p><p>上面的例子建议改成:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;LocalLeader&gt;</span><span class="keyword">x</span> dd</span><br></pre></td></tr></table></figure><p>再看个例子:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> Q <span class="keyword">x</span></span><br><span class="line">:<span class="keyword">nnoremap</span>          Q dd</span><br></pre></td></tr></table></figure><p>normal 模式下, 按 Q, 发现执行的操作等同 x. 第二个 mapping 配置无效.</p><p>Buffer-Local mappings 会覆盖对应的通用的 mappings 配置.这点同 set options 不大一样, 待会会提到.</p></li><li><p>set options</p><p>基于 Buffer-Local 的设置, 用命令 <code>setlocal</code>.</p><p> 打开任意文件, 在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line">:<span class="keyword">setlocal</span> nonumber</span><br></pre></td></tr></table></figure><p>会发现行号已经消失.</p><p>需要注意的是, 如果 setlocal option 后, 又 set 了同一个 option, 则 setlocal 所做的改变会被覆盖.</p><p>比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">setlocal</span> nonumber</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line">:<span class="keyword">setlocal</span> <span class="keyword">number</span>?</span><br></pre></td></tr></table></figure><p>此时输出的结果是 number.</p></li><li><p>abbreviations</p><p>同 mappings, Buffer-Local abbreviations 也只需要在<code>abbrev</code> 后, 添加一个<code>&lt;buffer&gt;</code>, 看个例子:</p><p>在当前打开的文件下, 命令行模式输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iabbrev</span> <span class="symbol">&lt;buffer&gt;</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>切换到 insert 模式, 输入log, 会替换成 logger.debug.</p><p>此时, 更换另一个文件, 再次在 insert 模式下, 输入log, 发现没有变化.</p><p>同 mappings 一样, Buffer-Local abbreviations 会覆盖通用的 abbreviations.</p><p>刚刚设置的文件中, 命令行模式输入:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">:iabbrev <span class="keyword">log</span> logger.<span class="keyword">info</span></span><br></pre></td></tr></table></figure><p>切换到 insert 模式, 输入log, 替换的仍然是 Buffer-local 设置的 logger.debug.</p></li></ul><p>OK. Buffer-Local 基本缕完, 下一章来点不一样的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章的内容结合了前面学到的知识.&lt;/p&gt;
&lt;p&gt;Buffer-Local, 顾名思义, 基于 Buffer,  只针对当前 Buffer 有效.&lt;/p&gt;
&lt;p&gt;前面遇到的 mappings, options , abbreviations, 当需要只对当前 Buffer 
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Abbreviations</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-abbrev/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-abbrev/</id>
    <published>2021-12-23T14:01:41.000Z</published>
    <updated>2021-12-23T14:05:29.705Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 的 Abbreviations 特性, 同 mappings 有些相似, 但是主要用于插入, 替换.</p><p>这里按照原书的思路简单说一下应用.</p><p>先来看个例子.</p><p>在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iabbrev</span> ned end</span><br></pre></td></tr></table></figure><p>然后在insert 模式下, 输入 ned 后回车或者退出insert 模式, 会发现 ned 已经变成了 end. [多嘴一句: 为什么是insert 模式下呢? 因为iabbrev 前面有个i….]</p><p>这个功能可以很方便纠正一些拼写错误.</p><p>鉴于我常常容易打出 ned, 所以我把这个 iabbrev 放在了 <code>.vimrc</code> 中. 哈哈.</p><p>不过需要注意的是, 用 abbreviation 替换的, 不可以是关键字 keyword, 包括所有的 ASCII 字符, 下划线(_)等.</p><p>可以通过<code>:h isfname</code> 来查看 Vim 中的所有关键字.</p><p>为了省去大伙看文档懵逼的时间, 作者在文中贴心地给了一个简单的记忆方法: 用 abbreviation 来替换的, 不可以是单个字母, 数字或者下划线.</p><p>说到这里, 你大概会猜, 支持扩展缩略的插件, 比如 <a href="https://github.com/mattn/emmet-vim">mattn/emmet-vim</a> 应该是 Abbreviations 的一个典型应用吧.</p><p>我当时就是这么想的, 屁颠屁颠跑去看 <a href="https://github.com/mattn/emmet-vim">mattn/emmet-vim</a> 的源代码想验证下猜想, 结果发现没有 iabbrev 的身影, 取而代之的是 substitute() 函数.🤪 [核心代码都是autoload目录下, 如果你也好奇的话….]</p><p>切回 Abbreviations.</p><p>如果想要清除刚刚的缩写设置, 可以使用:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:iunabbrev</span> ned</span><br></pre></td></tr></table></figure><p>如果想要清除所有的缩写设置, 可以使用:</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:abclear</span></span><br></pre></td></tr></table></figure><p>其中, <code>ab</code> 是 <code>abbrev</code> 的缩写形式….</p><p>上面 ned 那个例子里, 用mapping 也可以实现一样的功能.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:inoremap</span> ned <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那为什么不用 mapping呢?</p><p>因为 mappings 不会考虑需要替换的字符的上下文情况.[Mappings don’t take into account what characters come before or after the map]</p><p>作者在书中给了个例子. 但是这个例子很奇怪, inoremap 无效.</p><p>所以, 我来整了个简单点的.</p><p>在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">inoremap</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>在 insert 模式下, 输入 log, log会自动更换成 logger.debug, 但是当你输入 blog 时, 发现也被自动替换成了blogger.debug.</p><p>这显然不是我们想要的.</p><p>换成 <code>iabbrev</code> 就可以避免这个坑.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iunmap</span> <span class="built_in">log</span></span><br><span class="line">:<span class="keyword">iabbrev</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>此处用 <code>iunmap</code> 来清除刚刚设置的mapping.</p><p>这时在 insert 模式下, 输入 blog, 发现不会被替换了.</p><p>Bravo~</p><p>OK, Abbreviations 可以告一段落. 自己试着写几个 abbrev 来帮助更正拼写吧😄️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vim 的 Abbreviations 特性, 同 mappings 有些相似, 但是主要用于插入, 替换.&lt;/p&gt;
&lt;p&gt;这里按照原书的思路简单说一下应用.&lt;/p&gt;
&lt;p&gt;先来看个例子.&lt;/p&gt;
&lt;p&gt;在命令行模式下, 输入:&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>editing your vimrc</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-edit-your-vimrc/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-edit-your-vimrc/</id>
    <published>2021-12-22T12:46:36.000Z</published>
    <updated>2021-12-23T08:17:28.375Z</updated>
    
    <content type="html"><![CDATA[<p>这一章结合前面所学的, 实现了两个功能: edit and source your vimrc.</p><p>当你编辑文件时, 如果想要修改 <code>.vimrc</code> 文件, 并使刚刚修改的配置生效, 有什么快捷的方式?</p><p>作者给了如下解决方法.</p><p>编辑<code>.vimrc</code>, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>ev :<span class="keyword">vsplit</span> $MYVIMRC<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">sv</span> :<span class="keyword">source</span> $MYVIMRC<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>其中, MYVIMRC 是Vim 提供的环境变量, 指的是 <code>.vimrc</code> 文件的位置, 可通过<code>:echo $MYVIMRC</code> 查看 MYVIMRC 的值.</p><p>这里提供了两个 mappings, 按<code>&lt;Leader&gt;ev</code> , 会打开一个新的split, 编辑  <code>.vimrc</code>  文件. 按<code>&lt;Leader&gt;sv</code> , source   <code>.vimrc</code>文件 .</p><p>不得不说, 真的超方便.</p><p>有了范例, 我也倒腾了一个编辑 <code>.tmux.conf</code> 的mapping.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>et :<span class="keyword">vsplit</span> $HOME/.tmux.<span class="keyword">conf</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>按<code>&lt;Leader&gt;et</code> , 编辑  <code>.tmux.conf</code>  文件.</p><p>同样也可以来个source:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">st</span> :!tmux <span class="keyword">source</span>-<span class="keyword">file</span> $HOME/.tmux.<span class="keyword">conf</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p> 但是通常需要 source  <code>.tmux.conf</code> 的场合, 也多是在 tmux 中, 直接快捷键 <code>Crtl-b + r</code> 就可以了.所以  source <code>.tmux.conf</code> 的这个 mapping 也可以不配置.</p><p>OK,  本章结束, 你也来配置个玩一玩吧^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章结合前面所学的, 实现了两个功能: edit and source your vimrc.&lt;/p&gt;
&lt;p&gt;当你编辑文件时, 如果想要修改 &lt;code&gt;.vimrc&lt;/code&gt; 文件, 并使刚刚修改的配置生效, 有什么快捷的方式?&lt;/p&gt;
&lt;p&gt;作者给了如下解决方法.
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Leaders</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-leaders/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-leaders/</id>
    <published>2021-12-21T13:10:12.000Z</published>
    <updated>2021-12-22T01:50:33.186Z</updated>
    
    <content type="html"><![CDATA[<p>来到了常见的 Leader.</p><p>初学时, 我简单地把 Leader 理解成一个 namespace, 好比 tmux 的 <code>Ctrl+b</code>. 现在看, 也没有偏差太多.</p><p>你可以把 Leader 看成是 Vim 内置的 prefix key.</p><p>Leader 的值存在 mapleader 变量中, 如果 mapleader 未初始化或者值为空, 则默认为 反斜杠 <code>\</code> .</p><p>这里注意: mapleader 是一个 variable, 不是一个 option, 使用 <code>:set mapleader?</code> 会报错的.</p><p>相应的, 如果想要修改 Leader 键, 可以通过给 mapleader 赋值来实现.</p><p>编辑<code>.vimrc</code>, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleader=<span class="string">&quot;-&quot;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>d dd</span><br></pre></td></tr></table></figure><p>保存退出, source 后, 打开文件, 在 Normal 模式下, 按 <code>-d</code>, 等同于执行 <code>dd</code>. 即删除当前行. 此时 <code>&lt;Leader&gt;</code> 已变成了<code>-</code> 了, 如果按<code>\d</code> , 会发现无效.</p><p>mapleader 还有一个小兄弟, 叫 maplocalleader,  在 Vim中用特殊的字符串 <code>&lt;LocalLeader&gt;</code> 来表示.</p><p>同样, 可以通过赋值 maplocalleader 来设置   <code>&lt;LocalLeader&gt;</code>  :</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> <span class="attr">maplocalleader</span> = <span class="string">&quot;\\&quot;</span></span><br></pre></td></tr></table></figure><p>那  <code>&lt;LocalLeader&gt;</code>  是用来干嘛的呢?</p><p>作者在书中提到  <code>&lt;LocalLeader&gt;</code>  用来作为特定文件类型中的前置键.</p><blockquote><p>This is meant to be a prefix for mappings that only take effect for certain types of files, like Python files or HTML files.</p></blockquote><p>这个同官方文档中给出的, 稍稍有些区别.</p><p>Vim 官方文档提到的是 <code>&lt;LocalLeader&gt;</code>  用于只针对当前 buffer 有效的mappings.</p><blockquote><p><code>&lt;LocalLeader&gt;</code>  is to be used for mappings which are local to a buffer.  Example:<br>:map <buffer> <code>&lt;LocalLeader&gt;</code>A  oanother line<Esc></p></blockquote><p>但是文档中也提到了:</p><blockquote><p>In a global plugin <code>&lt;Leader&gt;</code> should be used and in a filetype plugin <code>&lt;LocalLeader&gt;</code>.</p></blockquote><p>全局插件使用 <code>&lt;Leader&gt;</code>  , 特定文件类型的插件, 使用 <code>&lt;LocalLeader&gt;</code>  .[有关Plugin, 后面会单独再介绍]</p><p>当然, 平日里我基本用不到<code>&lt;LocalLeader&gt;</code> , 这里就不折腾了.</p><p>可以查看官方文档了解更多.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:h</span> mapleader</span><br><span class="line"><span class="symbol">:h</span> maplocalleader</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来到了常见的 Leader.&lt;/p&gt;
&lt;p&gt;初学时, 我简单地把 Leader 理解成一个 namespace, 好比 tmux 的 &lt;code&gt;Ctrl+b&lt;/code&gt;. 现在看, 也没有偏差太多.&lt;/p&gt;
&lt;p&gt;你可以把 Leader 看成是 Vim 内置的 pref
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>mapping</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-mapping/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-mapping/</id>
    <published>2021-12-15T10:37:10.000Z</published>
    <updated>2022-01-11T08:06:06.155Z</updated>
    
    <content type="html"><![CDATA[<p>mapping  顾名思义, <code>map a b</code>, 当我执行 a 操作时, 它会做 b 操作会做的事.</p><p>看个例子, 在 Vim 命令行中, 输入:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">map</span> <span class="string">\</span> dd</span><br></pre></td></tr></table></figure><p>表示, 在 normal 模式下, 按下<code>\</code>, 就会删除当前光标所在的行.</p><p>mapping的设置, 跟模式有关系.</p><p><code>nmap</code> : normal mode 下的 mapping, 只在 normal 模式下有效.</p><p><code>vmap</code> : visual mode 下的 mapping, 只在 visual 模式下有效.</p><p><code>imap</code> : insert mode 下的 mapping, 只在 insert 模式下有效.</p><p><code>omap</code> : operator-pending mode 下的 mapping, 只在 operator-pending 模式下有效.</p><p><code>map</code>: normal, visual, operating mode 下的 mapping, 在 normal/visual/operator-pending 模式下有效.</p><p>map 有一个大坑, 叫做 Recursion, 书中给了一个例子, 比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nmap</span> dd O<span class="symbol">&lt;esc&gt;</span>jddk</span><br></pre></td></tr></table></figure><p>normal 模式下, 按下dd, 等同于执行了<code>O&lt;esc&gt;jddk</code> , 而 <code>O&lt;esc&gt;jddk</code> 也有 <code>dd</code>, Vim 就会再次 mapping, 如此无穷尽….</p><p>解决方法是使用<code>noremap</code>,  nonrecursive mapping. 修改上面那个命令:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> dd O<span class="symbol">&lt;esc&gt;</span>jddk</span><br></pre></td></tr></table></figure><p>这样就正常了. 鉴于 noremap 能避雷,  作者给到的意见时, <strong>Always</strong> using  noremap instead of map. </p><p>再看个例子:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:nnoremap</span> &lt;C-s&gt;  <span class="symbol">:suspend&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>上述命令表示, normal 模式下, 按住 Ctrl + s, 就等同于在命令行输入了<code>:suspend</code> 然后回车 ,这里  <code>&lt;CR&gt;</code> 表示Enter回车键.</p><p>都说到<code>&lt;CR&gt;</code> , 不妨来看看 VimScript 中 的 一些常用的 keycodes :</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">&lt;Esc&gt;</span> : 代表 Esc 键</span><br><span class="line"><span class="attribute">&lt;C-&#123;key&#125;&gt;</span> : Ctrl + 任意键, 通常是字母键</span><br><span class="line"><span class="attribute">&lt;S-&#123;key&#125;&gt;</span> : Shift + 任意键, 通常是字母键</span><br><span class="line"><span class="attribute">&lt;CR&gt;</span> : Enter键,也可以用<span class="attribute">&lt;Enter&gt;</span>, <span class="attribute">&lt;Return&gt;</span> 来表示</span><br><span class="line"><span class="attribute">&lt;Space&gt;</span> : 空格键</span><br><span class="line"><span class="attribute">&lt;Leader&gt;</span> : Leader 键</span><br><span class="line"><span class="attribute">&lt;Left&gt;</span> : 左移方向键, 类似有<span class="attribute">&lt;Right&gt;</span>, <span class="attribute">&lt;Up&gt;</span>, <span class="attribute">&lt;Down&gt;</span></span><br></pre></td></tr></table></figure><p>那么, 如何知道 VimScript 中所有 key 的特殊标记? 用万能的<code>:help</code>  就好了, 命令行输入:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:h</span> key-notation</span><br></pre></td></tr></table></figure><p>可以查看所有的 key-notation.</p><p>我还记得刚入门时, 有时候看到别人的 vimrc 文件中, 有些 keycode 是全部小写的, 比如 <code>&lt;cr&gt;</code>, <code>&lt;esc&gt;</code>, 当时觉得, 有的人大写, 有的人小写, 哪种才是规范的呢? 直到看了文档, 才知道官方是首字母大写, 也算解了我的一个小困惑.</p><p>Vim 中有个特殊的 mapping, <code>&lt;Nop&gt;</code>, 表示什么也不做. 比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">inoremap</span> <span class="symbol">&lt;Esc&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br></pre></td></tr></table></figure><p>Insert 模式下, 按下 Esc 键, 什么也没有做. [慎用!!!]</p><p>现在, 我们可以用学到的知识来写个简单的禁止使用上下左右键的功能:</p><p>在 <code>.vimrc</code> 文件中, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; disable up, down, leaf, right</span></span><br><span class="line"><span class="comment">&quot; normal mode</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; visual mode</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; insert mode</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br></pre></td></tr></table></figure><p>这样就只能用 hjkl 了.</p><p>好了, 除了 Operator-Pending Mappings 外, 基本算是缕清了, 整点好吃的, 犒劳下自己吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mapping  顾名思义, &lt;code&gt;map a b&lt;/code&gt;, 当我执行 a 操作时, 它会做 b 操作会做的事.&lt;/p&gt;
&lt;p&gt;看个例子, 在 Vim 命令行中, 输入:&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>set option</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-set-option/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-set-option/</id>
    <published>2021-12-15T10:36:51.000Z</published>
    <updated>2021-12-22T01:50:17.426Z</updated>
    
    <content type="html"><![CDATA[<p>新手基本都会在大佬们的.vimrc 文件中看到不少 set option. </p><p>我们可以把 option 看作是 built-in configuration.</p><p>option 可以是布尔值, 类似开关, <code>set &#123;option&#125;</code>, <code>set no&#123;option&#125;</code>, 也可以赋值 <code>set &#123;option&#125;= &#123;value&#125;</code>. 以 number 为例:</p><p>在 Vim 命令行中, 输入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出 number 的当前值</span></span><br><span class="line">:set number?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加行号显示</span> </span><br><span class="line">:set number</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭行号显示, 通用模式no&#123;option&#125;</span></span><br><span class="line">:set nonumber</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换</span></span><br><span class="line">:set number!</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置成默认值</span></span><br><span class="line">:set number&amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置所有的 option 为系统默认值</span></span><br><span class="line">:set all&amp;</span><br></pre></td></tr></table></figure><p>这里简单提一下, 比较常用的 path. </p><p>在 Vim 命令行中, 输入当前Path:</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> <span class="built_in">path</span>?</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code> path=.,/usr/include,,</code></p><p>其中:</p><ul><li><p>. 指的是当前打开文件所在的目录.</p></li><li><p>/usr/include 是 C Libraries 头文件目录</p></li><li><p>, 指得是当前目录</p></li></ul><p>建议将经常访问的目录添加到 path, 比如:</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> path+=app/<span class="keyword">models</span>/</span><br></pre></td></tr></table></figure><p>这样就用<code>find</code> 就顺手多了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新手基本都会在大佬们的.vimrc 文件中看到不少 set option. &lt;/p&gt;
&lt;p&gt;我们可以把 option 看作是 built-in configuration.&lt;/p&gt;
&lt;p&gt;option 可以是布尔值, 类似开关, &lt;code&gt;set &amp;#123;option
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>echo vs echom</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-echo/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-echo/</id>
    <published>2021-12-15T10:32:36.000Z</published>
    <updated>2021-12-22T02:27:20.426Z</updated>
    
    <content type="html"><![CDATA[<p>echo 和 echom 都用于输出, 但是 echom 输入的内容, 会被保存在 messages 中.</p><p>在 Vim 命令行中, 输入:</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:echo</span> <span class="string">&quot;hello, world through echo&quot;</span></span><br><span class="line"><span class="symbol">:echom</span> <span class="string">&quot;hello, world through echom&quot;</span></span><br><span class="line"><span class="symbol">:messages</span></span><br></pre></td></tr></table></figure><p>可以在 messages 中看到 echom 输出的内容.</p><p>我之前会觉得 echo 没啥用, 直到看到 Max Cantor 的一个分享视频 <a href="https://www.youtube.com/watch?v=XA2WjJbmmoM&list=WL">How to Do 90% of What Plugins Do (With Just Vim)</a> , 他当时尝试用  <code>:echo expand(&#39;%&#39;)</code> 输出当前文件的相对路径, 看到结果的那一刻,  Max 情不自禁 yes了一下, 那个开心啊, 多像跑通代码的我们, 一下子让我记住了expand(“%”), 也对echo 有了印象……..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;echo 和 echom 都用于输出, 但是 echom 输入的内容, 会被保存在 messages 中.&lt;/p&gt;
&lt;p&gt;在 Vim 命令行中, 输入:&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
</feed>
