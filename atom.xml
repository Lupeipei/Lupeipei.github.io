<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucia</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lupeipei.github.io/"/>
  <updated>2022-02-23T10:40:47.471Z</updated>
  <id>http://lupeipei.github.io/</id>
  
  <author>
    <name>Lucia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Traefik 改用 acme.sh 为域名生成证书</title>
    <link href="http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/"/>
    <id>http://lupeipei.github.io/posts/using-acme-sh-to-generate-certs-for-tls-in-traefik/</id>
    <published>2022-02-23T10:21:58.000Z</published>
    <updated>2022-02-23T10:40:47.471Z</updated>
    
    <content type="html"><![CDATA[<p>Traefik 踩坑记录.</p><span id="more"></span> <p>Traefik 可以配置自动生成证书的 ACME 供应商, 比如Let’s Encrypt.</p><p>官方文档提到会自动更新证书. 但实际情况是, 到期了证书有时并没有更新, 导致出现证书过期的情况. </p><p>这里记录下在服务器上配置 Traefik 时, 改用 acme.sh 来签证书并自动更新的步骤. </p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>默认服务器为Ubuntu, traefik 已启用, 对应的docker-compose.yml 存放在/opt/global目录下.</p><p>其中<code>/opt/global/docker-compose.yml</code> 的具体内容如下.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们挂载了/opt/global 目录下的 <code>traefik.toml</code>, 该文件存放了一些默认的配置, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">entryPoints</span>]</span><br><span class="line">  [<span class="string">entryPoints.web</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:80&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.websecure</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:443&quot;</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">entryPoints.traefik</span>]</span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;:8080&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">api</span>]</span><br><span class="line">  <span class="string">insecure</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">dashboard</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[<span class="string">log</span>]</span><br><span class="line">  <span class="string">level=</span> <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">certificatesResolvers</span>]</span><br><span class="line">  [<span class="string">certificatesResolvers.lets-encrypt</span>]</span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme</span>]</span><br><span class="line">      <span class="string">email</span> <span class="string">=</span> <span class="string">&quot;myEmail@gmail.com&quot;</span></span><br><span class="line">      <span class="string">storage</span> <span class="string">=</span> <span class="string">&quot;acme.json&quot;</span></span><br><span class="line">    [<span class="string">certificatesResolvers.lets-encrypt.acme.tlsChallenge</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">providers.docker</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">exposedByDefault=false</span></span><br><span class="line">  <span class="string">network</span> <span class="string">=</span> <span class="string">&quot;my_proxy&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">providers.file</span>]</span><br><span class="line">  <span class="string">watch</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">directory=&quot;/providers&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到我们声明了一个证书解析器 (certificatesResolvers)  lets-encrypt. </p><p>而 我们需要使用 acme.sh 生成证书的 Web项目, 存放在/opt/web/ 下, 其 <code>docker-compose.yml</code> 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.entrypoints=web&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web-http.middlewares=my-web-https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.middlewares.my-web-https.redirectscheme.scheme=https&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.rule=Host(`example.com`, `api.example.com`) &amp;&amp; PathPrefix(`/`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.certresolver=lets-encrypt&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里可以看到, 我们给 web 配置的 certresolver 配置为之前定义的 lets-encrypt. </p><p> 如果查看 <code>acme.json</code> 文件, 你会看到类似如下内容, Certificates 部分有我们的 <code>example.com</code> 及子域名<code>api.example.com</code>  :</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lets-encrypt&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Account&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Email&quot;</span>: <span class="string">&quot;myEmail@gmail.com&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Registration&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;valid&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;contact&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;mailto:myEmail@gmail.com&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;https://acme-v02.api.letsencrypt.org/acme/acct/xxxxx&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;PrivateKey&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;KeyType&quot;</span>: <span class="string">&quot;4096&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Certificates&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example.com&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sans&quot;</span>: [<span class="string">&quot;api.example.com&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;example1.com&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      .........</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时, 网站正常访问.</p><p>现在我们来更改 <code>example.com</code> 的 tls 配置, 证书改用 acme.sh 来签发.</p><h4 id="改用-acme-sh"><a href="#改用-acme-sh" class="headerlink" title="改用 acme.sh"></a>改用 acme.sh</h4><p>acme 验证的主要方式是 standalone 和 webroot.</p><p>鉴于 standalone 需要占用80或者443端口, 导致需要暂停服务器,这里我们使用 webroot 方式来验证域名.</p><p> webroot 模式下, acme 会在网站根目录下生成一个临时子目录 <code>.well-known/acme-challenge</code>，然后服务器会向这个路径发请求，如果请求成功，则验证通过, 随后会删除掉这个临时目录. </p><p>我们将根目录web root 默认为 /var/www, 同时在当前目录下, 新增两个文件夹, 用来分别挂载 /var/www 和 /acme.sh 目录.</p><p>/opt/global/ 目录下, 新建文件 <code>docker-compose.acme.sh.yml</code>, 内容如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">acme.sh:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">neilpang/acme.sh:3.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">acme.sh</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/var/www</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">daemon</span></span><br></pre></td></tr></table></figure><p>新增文件夹:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir nginx acme.sh</span><br></pre></td></tr></table></figure><p>生成的证书会存放在acme.sh 目录中, 而 nginx 目录用于验证域名.</p><p>这里我们起一个nginx 服务, 使得 traefik 将所有匹配 <code>/.well-known</code> 的路径请求都转发到这个nginx 上. 同时, 将当前目录下的 nginx 目录挂载到 nginx 服务的静态文件默认地址 <code>/usr/share/nginx/html</code> . </p><p>这样, 当使用 webroot 模式验证域名时, acme.sh 就会在 <code>/opt/global/nginx</code> 目录下,生成临时子目录 <code>.well-known/acme-challenge</code>, 而验证时, 访问 <code>/usr/share/nginx/html</code>, 也就是访问我们的 <code>/opt/global/nginx</code> 目录.</p><p>我们新增文件 <code>/opt/global/docker-compose.nginx.yml</code> , 添加如下内容:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.rule=HostRegexp(`&#123;catch_all:.*&#125;`) &amp;&amp; PathPrefix(`/.well-known`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.global-nginx.priority=999&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.global-nginx.loadbalancer.server.port=80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx:/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my_proxy:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里有一点需要提一下.</p><p>我们给 nginx 服务配置 traefik 时,  设置了priority的值为999. 默认情况下,  traefik 中路径的 priority是根据rule的长度来决定的. 这里我们希望所有带有 <code>/.well-known</code> 的请求都转发到这个 nginx 上, 所以手动设置了999.</p><p>启动 nginx:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.nginx.yml up -d</span><br></pre></td></tr></table></figure><p>nginx 启动后, 我们启动 acme.sh.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --file docker-compose.acme.sh.yml up -d</span><br></pre></td></tr></table></figure><p>开始签证书啦.</p><p>第一次使用acme.sh时, 需要注册用户邮箱:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it acme.sh sh -l</span><br><span class="line">acme.sh --register-account -m myEmail@gmail.com</span><br><span class="line">acme.sh --issue -d example.com -d api.example.com --webroot /var/www</span><br></pre></td></tr></table></figure><p>正常情况下, 会一切顺利. 默认CA是ZeroSSL.com</p><p>如果 acme.sh 签发证书时 Timeout了, 请设置代理. </p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><p>证书签发成功后, 我们查看 <code>/opt/global/acme.sh/example.com</code> 目录, 会看到刚刚生成的证书.</p><p>现在, 我们把新鲜出炉的证书用起来.</p><p>修改 <code>/opt/global/docker-compose.yml</code> , 将 <code>/opt/global/acme.sh</code> 目录挂载到 traefik 中:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./providers:/providers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./acme.sh:/acme.sh</span></span><br></pre></td></tr></table></figure><p>然后我们在traefik 的动态配置中把证书放进去.</p><p>在 <code>/opt/global/providers</code> 目录下, 新增 <code>example_com_certs.toml</code> 文件, 写入我们的证书路径:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[tls.certificates]]</span></span><br><span class="line">  <span class="attr">certFile</span> = <span class="string">&quot;/acme.sh/example.com/fullchain.cer&quot;</span></span><br><span class="line">  <span class="attr">keyFile</span> = <span class="string">&quot;/acme.sh/example.com/example.com.key&quot;</span></span><br></pre></td></tr></table></figure><p>同时, 我们需要将 <code>/opt/global/acme.json</code> 文件中 Certificates 部分, 有关 example.com 的证书内容删除.</p><p>最后, 修改 <code>/opt/web/docker-compose.yml</code>, 把tls 部分的配置, 改为options=default.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-docker-image</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">    <span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.entrypoints=websecure&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.my-web.tls.options=default&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.my-web-http.loadbalancer.server.port=80&quot;</span></span><br></pre></td></tr></table></figure><p>重启 traefik.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart traefik</span><br></pre></td></tr></table></figure><p>再次请求 <a href="https://example.com/">https://example.com</a>, 会发现证书已经签成由ZeroSSL 颁发的证书. </p><p>替换完成. 撒花! 🥳</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://doc.traefik.io/traefik/">traefik doc</a></p><p><a href="https://doc.traefik.io/traefik/https/acme/">traefick: let’s Encrypt</a></p><p><a href="https://github.com/acmesh-official/acme.sh">acme.sh</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traefik 踩坑记录.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Acme" scheme="http://lupeipei.github.io/tags/Acme/"/>
    
      <category term="Traefik" scheme="http://lupeipei.github.io/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>Using Puppeteer with executablePath in Electron</title>
    <link href="http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/"/>
    <id>http://lupeipei.github.io/posts/using-puppeteer-with-executablePath-in-electron/</id>
    <published>2022-02-15T08:31:40.000Z</published>
    <updated>2022-02-22T06:37:44.224Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Electron 踩坑过程.</p><span id="more"></span> <h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用 Electron 创建桌面应用, 程序中调用了 <a href="https://github.com/puppeteer/puppeteer">puppeteer</a>,  开发环境下一切正常, 使用 electron-builder 在Mac上打包成 Windows下的可执行文件后, 程序在Windows上跑时一直卡着不动.</p><p>Debug后发现一直卡在 <code>puppeteer.launch</code> .</p><p>环境:</p><p>puppeteer: 13.0.1</p><p>electron: 17.0.0</p><p>electron-builder: 22.10.4</p><p>node: 12.22.3</p><p>yarn: 1.22.10</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>Debug后发现问题的根源在于 MacOS 上打包时,  node_module 中 puppeteer 的Chrome, 是适配MacOS系统版本的, 这个Chrome 在 Windows下肯定是无法正常运行的.</p><p>参考<a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a> 中, scriptify 的回复:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/imagespuppeteer.jpg"></p><p>自己写一个脚本, 本地下载个Windows版本的chrome, 然后打包进去, <code>puppeteer.launch</code> 时指定 executablePath.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载 chrome.</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browserFetcher = puppeteer.createBrowserFetcher(&#123; <span class="attr">platform</span>: <span class="string">&quot;win32&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> revisionInfo = <span class="keyword">await</span> browserFetcher.download(<span class="string">&#x27;533271&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(revisionInfo)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>按照 scriptify 给的方法, 修改package.json:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;asar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;asarUnpack&quot;</span>: <span class="string">&quot;node_modules/puppeteer/.local-chromium/win32-533271/**/*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用 <code>puppeteer.launch</code> 的地方:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> homeDir = puppeteer.executablePath().split(<span class="string">&#x27;app.asar&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> executablePath = homeDir.concat(<span class="string">&quot;app.asar.unpacked\\node_modules\\puppeteer\\.local-chromium\\win32-533271\\chrome-win32\\chrome.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: executablePath, <span class="attr">args</span>: [ <span class="string">&quot;--disable-gpu&quot;</span>, <span class="string">&quot;--disable-dev-shm-usage&quot;</span>, <span class="string">&quot;--disable-setuid-sandbox&quot;</span>, <span class="string">&quot;--no-sandbox&quot;</span> ] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>诡异的是, 打包后扔进 Windows里面运行, 发现 Chrome.exe 文件是存在的. 但是 puppeteer 依然没有成功运行.</p><p>最后无奈, 直接换成 在Windows下打包, 同时指定 executablePath.问题解决.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/puppeteer/puppeteer/issues/2134">puppeteer issue: run from electron</a></p><p><a href="https://yrq110.me/post/front-end/the-right-way-to-use-puppeteer-in-electron/">配置Electron中Puppeteer executablePath的正确姿势</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Electron 踩坑过程.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>As I began to love myself</title>
    <link href="http://lupeipei.github.io/posts/as-I-began-to-love-myself/"/>
    <id>http://lupeipei.github.io/posts/as-I-began-to-love-myself/</id>
    <published>2022-02-13T13:53:12.000Z</published>
    <updated>2022-02-13T14:04:12.091Z</updated>
    
    <content type="html"><![CDATA[<p>读到一首不错的现代诗, 分享下 ^_^</p><span id="more"></span><p>As I began to love myself,<br>I found that anguish and emotional suffering are only warning signs that I was living against my own truth.<br>Today, I know, this is “authenticity”.</p><p>As I began to love myself,<br>I understood how much it can offend somebody,<br>As I try to force my desires on this person, even though I knew the time was not right and the person was not ready for it, and even though this person was me.<br>Today I call it “respect”.</p><p>As I began to love myself,<br>I stopped craving for a different life, and I could see that everything that surrounded me was inviting me to grow.<br>Today I call it “maturity”.</p><p>As I began to love myself,<br>I understood that at any circumstance, I am in the right place at the right time, and everything happens at the exactly right moment.<br>So I could be calm.<br>Today I call it “self-confidence”.</p><p>As I began to love myself,<br>I quit steeling my own time, and I stopped designing huge projects for the future.<br>Today, I only do what brings me joy and happiness, things I love to do and that make my heart cheer, and I do them in my own way and in my own rhythm.<br>Today I call it “simplicity”.</p><p>As I began to love myself,<br>I freed myself of anything that is no good for my health – food, people, things, situations, and everything that drew me down and away from myself.<br>At first I called this attitude a healthy egoism.<br>Today I know it is “love of oneself”.</p><p>As I began to love myself,<br>I quit trying to always be right, and ever since I was wrong less of the time.<br>Today I discovered that is “modesty”.</p><p>As I began to love myself,<br>I refused to go on living in the past and worry about the future.<br>Now, I only live for the moment, where everything is happening.<br>Today I live each day, day by day, and I call it “fulfillment”.</p><p>As I began to love myself,<br>I recognized that my mind can disturb me and it can make me sick.<br>But As I connected it to my heart, my mind became a valuable ally.<br>Today I call this connection “wisdom of the heart”.</p><p>We no longer need to fear arguments, confrontations or any kind of problems with ourselves or others.<br>Even stars collide, and out of their crashing new worlds are born.<br>Today I know “that is life”.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读到一首不错的现代诗, 分享下 ^_^&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://lupeipei.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://lupeipei.github.io/tags/Life/"/>
    
      <category term="Poem" scheme="http://lupeipei.github.io/tags/Poem/"/>
    
  </entry>
  
  <entry>
    <title>electron 代理配置</title>
    <link href="http://lupeipei.github.io/posts/set-proxy-for-electron/"/>
    <id>http://lupeipei.github.io/posts/set-proxy-for-electron/</id>
    <published>2022-02-07T12:10:53.000Z</published>
    <updated>2022-02-07T12:27:02.284Z</updated>
    
    <content type="html"><![CDATA[<p>踩了两次坑, 记录下.</p><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>node version: v12.22.3<br>yarn version: 1.22.10</p><p>终端执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>一直报错:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Output:</span></span><br><span class="line"><span class="symbol">RequestError:</span> read ETIMEDOUT</span><br></pre></td></tr></table></figure><p>已经设置了代理, 无效:</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">http_proxy=http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7890</span></span><br><span class="line">all_proxy=socks5:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7891</span></span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>参考 <a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a>, node 10+需要设置环境变量.<br><code>GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE</code> 采用默认值<code>GLOBAL_AGENT_</code></p><p>分别设置 <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTP_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLOBAL_AGENT_HTTPS_PROXY</span>=http://127.0.0.1:7890</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ELECTRON_GET_USE_PROXY</span>=1</span><br></pre></td></tr></table></figure><p>重新执行:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> <span class="comment">--dev electron</span></span><br></pre></td></tr></table></figure><p>OK.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.electronjs.org/docs/latest/tutorial/installation#proxies">Advanced Installation Instructions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;踩了两次坑, 记录下.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="ErrorTracking" scheme="http://lupeipei.github.io/tags/ErrorTracking/"/>
    
      <category term="Electron" scheme="http://lupeipei.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Operator Pending Mappings</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-operator-pending-mappings/</id>
    <published>2022-01-13T13:37:12.000Z</published>
    <updated>2022-01-13T13:41:55.207Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. </p><p>官方文档中, 对 Operator-pending mappings 的解释是:</p><blockquote><p>Operator-pending mappings can be used to define a movement command that can be<br>used with any operator. </p></blockquote><p>Operator-pending mappings 可以用于定义会被执行的移动指令.[我这翻译的…]</p><p>看个简单的例子来理解.</p><p>打开文件test.txt, 内容如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> (<span class="keyword">some</span>) <span class="built_in">text</span> <span class="keyword">about</span> topic one.</span><br><span class="line"></span><br><span class="line">It has multiple (<span class="built_in">paragraphs</span>).</span><br><span class="line">part1(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part2(<span class="built_in">paragraph</span>) content.</span><br><span class="line">part3(<span class="built_in">paragraph</span>) content.</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>命令模式下, 执行:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">onoremap</span> <span class="selector-tag">p</span> <span class="selector-tag">i</span>(</span><br></pre></td></tr></table></figure><p>这时, 在 normal 模式下, 按<code>dp</code>, 等同于<code>di(</code>, 即删除<code>()</code> 里的内容.</p><p>这里默认从当前光标所在位置, 往下查找第一个<code>()</code>, 然后执行操作.</p><p>比如, 我们把光标移动到第三行 It has……, 按<code>dp</code>,  会发现 paragraphs 被删除了.</p><p>当光标停留在最后一行 end, 按<code>dp</code>, 发现无效.</p><p>如果想要消除光标所在位置, 就需要使用<code>&lt;C-u&gt;</code> CTRL-u.</p><p>来看个例子:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:onoremap i( :&lt;C-u&gt;normal!</span> 0f)vi(&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>此时, 按<code>di(</code>, 不管光标在哪里, 会删除光标所在行的第一个<code>()</code> 中的内容.</p><p>鉴于 Operator-pending mappings 我平时用到的很少, 也没有细细研究, 目前就不多扯了.</p><p>想要了解更多, 可以看官方文档:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">:h omap-<span class="meta">info</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面介绍 mapping 的时候, 留了个operator-pending 的坑, 现在来填. &lt;/p&gt;
&lt;p&gt;官方文档中, 对 Operator-pending mappings 的解释是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Operator-pending map
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>status lines</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-statusline/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-statusline/</id>
    <published>2022-01-10T07:48:42.000Z</published>
    <updated>2022-01-10T07:54:21.359Z</updated>
    
    <content type="html"><![CDATA[<p>来看看如何自定义状态栏显示.</p><p>Statusline 是 Vim 的一个 option, 可通过:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>查看当前的 statusline 配置.</p><p>当然, 我们也可以自定义状态栏的显示内容.</p><p>打开一个Markdown 文件,  命令行模式下, 输入:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=%f\ -\ FileType:\</span> %y</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo<span class="selector-class">.md</span> - FileType: <span class="selector-attr">[markdown]</span></span><br></pre></td></tr></table></figure><p>这里的 <code>%f</code>表示当前文件的相对路径, <code>%y </code> 表示文件的类型.</p><p>statusline 的设置, 有些类似 C 里面的 printf.</p><p>它的通用格式如下:</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">%-0</span><span class="template-variable">&#123;minwid&#125;</span><span class="xml">.</span><span class="template-variable">&#123;maxwid&#125;</span><span class="template-variable">&#123;item&#125;</span></span><br></pre></td></tr></table></figure><p>其中, 除了<code>%</code>  和 <code>&#123;item&#125;</code>, 其他都是可选的. 而 minwd, maxwid 分别指的是最小和最大宽度.</p><p>看几个简单的例子就清楚了.</p><p>显示行号:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %4l\ Total:\ %4L</span><br></pre></td></tr></table></figure><p>会看到状态栏显示如下类似内容:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>:    <span class="number">9</span> Total:   <span class="number">66</span></span><br></pre></td></tr></table></figure><p>这里设置了最短长度4, 默认用空格来补全.</p><p>可以设置为用0来补全:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:set statusline=Current:\</span> %04l\ Total:\ %04L</span><br></pre></td></tr></table></figure><p>状态栏显示如下:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Current</span>: <span class="number">0009</span> Total: <span class="number">0066</span></span><br></pre></td></tr></table></figure><p>再比如, 显示文件的绝对路径:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> <span class="attribute">statusline</span>=%.20F</span><br></pre></td></tr></table></figure><p>此处, 最大宽度设置为20, 状态栏显示如下:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;-<span class="keyword">on</span>-buffer-<span class="keyword">local</span>.md</span><br></pre></td></tr></table></figure><p>通过 <code>:h statusline</code> , 可以查看所有可用的 item 及其对应含义.</p><p>此外, 如果 statusline 是以 <code>%!</code> 开头, 比如 <code>:set statusline=%!MyStatusLine()</code> , 则表示<code>MyStatusLine()</code> 是个表达式, 这个表达式的结果才是 statusline 对应的值.</p><p>如果你安装了airline, 命令模式输入:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> statusline?</span><br></pre></td></tr></table></figure><p>会看到输出结果:</p><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line">statusline=%!airline<span class="function"><span class="keyword">#</span><span class="title">statusline</span><span class="params">(1)</span></span></span><br></pre></td></tr></table></figure><p>这里就是使用了<code>%!</code>.</p><p>书中还介绍了<code>%=</code>, 用于对齐, 这里就略过了.</p><p>OK, 本节结束, 我去吃点好吃的奖励下自己还没弃坑😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来看看如何自定义状态栏显示.&lt;/p&gt;
&lt;p&gt;Statusline 是 Vim 的一个 option, 可通过:&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>autocmd</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-autocmd/</id>
    <published>2021-12-31T09:31:55.000Z</published>
    <updated>2022-01-10T07:48:31.210Z</updated>
    
    <content type="html"><![CDATA[<p>autocmd 用于配置当某个确定事件发生时, 要执行的命令.</p><p>借用书中的例子, 看一下 autocmd 的基本结构:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:autocmd BufWritePre,BufRead *.html :normal</span> gg=G</span><br><span class="line"><span class="code">         ^                   ^      ^</span></span><br><span class="line"><span class="code">         |                   |      |</span></span><br><span class="line"><span class="code">         |                   |      需要执行的命令</span></span><br><span class="line"><span class="code">         |                   |</span></span><br><span class="line"><span class="code">         |                   模式, 用来过滤事件</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="code">         监听的事件</span></span><br></pre></td></tr></table></figure><p>这里 BufWritePre, BufRead 都是需要监听的事件, *.html 是需要过滤的模式, 整个命令的含义就是, 当开始写入 html 类型文件或者编辑 html 类型文件之前, 自动执行<code>:normal gg=G</code>, 也就是缩进代码.</p><p>[此处, BufWritePre 指的是开始将整个 Buffer 写入文件 , BufRead 指的是读文件后, 开始编辑. ]</p><p>通过<code>:h autocmd-events</code> 可以查看所有可以绑定 Autocommands 的事件列表.</p><p>其中, 最常用的 Event 是 FileType.</p><p>比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">autocmd</span> FileType javascript <span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;LocalLeader&gt;</span><span class="keyword">c</span> I//<span class="symbol">&lt;esc&gt;</span></span><br></pre></td></tr></table></figure><p>当打开一个javascript (.js)文件时, 执行<code>nnoremap &lt;buffer&gt; &lt;LocalLeader&gt;c I//&lt;esc&gt;</code>, 也就是按 <code>&lt;LocalLeader&gt;c</code>  会添加注释.</p><p>这里提一个简单的应用.</p><p>Vim中编辑 json 文件的时候, 默认是没有格式化的, 如何实现打开JSON文件时, 自动格式化内容, 方便阅读?</p><p>这里说一下我的做法.</p><p>安装 jq, 附上链接<a href="https://stedolan.github.io/jq/download/">download</a></p><p>修改 <code>.vimrc </code>, 添加:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">autocmd <span class="keyword">BufRead </span>*.<span class="keyword">json </span>%!<span class="keyword">jq </span><span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure><p>source 后, 打开 json 格式文件时, 可以看到已经格式化了.</p><p>autocmd 有一个兄弟 augroup. 可以把相近的 autocmd 放在一个group 中:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">augroup</span> testgroup</span><br><span class="line">  autocmd!</span><br><span class="line">  <span class="keyword">autocmd</span> BufWrite * :<span class="keyword">echom</span> <span class="string">&quot;Cats&quot;</span></span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p>这里使用<code>autocmd!</code>  来清理之前的 autocmd 设置.</p><p>augroup 的作用, 是用来避免重复定义 autocmd. 官网文档给到的解释是:</p><blockquote><p>This prevents having the autocommands defined twice (e.g., after sourcing the .vimrc file again).</p></blockquote><p>书中使用了一个 BufWrite + echom 的例子来说明使用 augroup 可以避免的问题, 同文档提到的一致, 这里就不细说了.</p><p>附上一个小小的tips. 如果你有执行 augroup 的例子, 会发现 messages 有些多,  想要清理的话, 可以使用<code>:messages clear</code></p><p>OK, 本章结束.</p><p>Bye 2021.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;autocmd 用于配置当某个确定事件发生时, 要执行的命令.&lt;/p&gt;
&lt;p&gt;借用书中的例子, 看一下 autocmd 的基本结构:&lt;/p&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>hexo 主题魔改记录</title>
    <link href="http://lupeipei.github.io/posts/custom-hexo-next-theme/"/>
    <id>http://lupeipei.github.io/posts/custom-hexo-next-theme/</id>
    <published>2021-12-28T13:32:58.000Z</published>
    <updated>2021-12-28T13:39:12.493Z</updated>
    
    <content type="html"><![CDATA[<p>自己折腾了下 Hexo 的 next 主题. 给 post 添加了字段 type. 为了避免下次崩了的时候, 我会对着自己写的代码一脸懵逼, 简单记录下……</p><span id="more"></span><p>本文基于 hexo-theme-next version 5.</p><h4 id="首页分页"><a href="#首页分页" class="headerlink" title="首页分页"></a>首页分页</h4><p>预期效果: 在首页不显示 post 中 type 为 book 的文章</p><p>思路: 修改首页的分页, 过滤掉 type 为 book 的文章.</p><p>具体实现:</p><p>参考 <a href="https://github.com/hexojs/hexo-generator-index">hexo-generator-index</a> ,  在 next 的 scripts 下, 添加文件 customIndexPagination.js, 内容如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.extend.generator.register(<span class="string">&#x27;customIndexPagination&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  locals.posts.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  set post default type as post, 设置默认值</span></span><br><span class="line">    <span class="keyword">if</span> (post.type == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      post.type = <span class="string">&quot;post&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">const</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">  <span class="comment">// filter posts with type == &quot;post&quot;, 过滤</span></span><br><span class="line">  <span class="keyword">const</span> postsWithoutbook = posts.find(&#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;post&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">  posts.data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (b.sticky || <span class="number">0</span>) - (a.sticky || <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> path = config.index_generator.path || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(path, postsWithoutbook, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h4><p>预期效果: 同一个 category 中, 所有 type 为 book 的 post 按照指定字段排序后再分页.这里按照 ranked 字段来排序 posts.</p><p>思路: 找到 page下对应的category, 按照 ranked 字段排序后, 调用 slice 实现分页.</p><p>具体实现:</p><p>next version 5 的模板用的是swig 语法, <a href="https://github.com/paularmstrong/swig">swig</a>已经多年不维护, 这个用起来还是折腾的.很多ES6语法不支持. 等后续有时间再折腾, 目前凑合用用swig….</p><p>修改 layout/category.swig, 在 Section部分, 添加如下代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;section id=&quot;posts&quot; class=&quot;posts-collapse&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class="line">    &lt;h2 &gt;&#123;&#123; page.category &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">...........</span><br><span class="line"></span><br><span class="line">  &#123;% set current = page.current %&#125;</span><br><span class="line">  &#123;% set pre = current - 1 %&#125;</span><br><span class="line">  &#123;% set perPage = config.per_page %&#125;</span><br><span class="line">  &#123;% set category = site.categories.findOne(&#123; &quot;name&quot;: page.category &#125;) %&#125;</span><br><span class="line">  &#123;% set posts = category.posts.sort(&#x27;ranked&#x27;) %&#125;</span><br><span class="line">  &#123;% set bookPost = posts.find(&#123; type: &#x27;book&#x27; &#125;) %&#125;</span><br><span class="line">  &#123;% set hasBookPost = bookPost.length &gt; 0 %&#125;</span><br><span class="line">  &#123;% if hasBookPost %&#125;</span><br><span class="line">    &#123;% set posts = posts.slice(perPage * pre, perPage * current) %&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;% set posts = page.posts %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">    &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">  ..........</span><br></pre></td></tr></table></figure><p>逻辑很简单, 主要调用 slice 来得到当前分页中的posts.</p><p>其中 site.categories 调用了findOne来查找当前页面的category, 参考的是 <a href="https://hexojs.github.io/warehouse/index.html">warehouse</a>.</p><p>OK.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/hexojs/hexo-pagination">hexo-pagination</a></p><p><a href="https://github.com/hexojs/hexo-generator-index">hexo-generator-index</a></p><p><a href="https://hexojs.github.io/warehouse/index.html">warehouse</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己折腾了下 Hexo 的 next 主题. 给 post 添加了字段 type. 为了避免下次崩了的时候, 我会对着自己写的代码一脸懵逼, 简单记录下……&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Hexo" scheme="http://lupeipei.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Buffer-Local</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-buffer-local/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-buffer-local/</id>
    <published>2021-12-28T01:34:51.000Z</published>
    <updated>2021-12-28T08:07:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>这一章的内容结合了前面学到的知识.</p><p>Buffer-Local, 顾名思义, 基于 Buffer,  只针对当前 Buffer 有效.</p><p>前面遇到的 mappings, options , abbreviations, 当需要只对当前 Buffer 生效时, 命令分别是什么呢?</p><p>来逐个说明下.</p><ul><li><p>mappings</p><p>打开任意文件, 在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">x</span> dd</span><br></pre></td></tr></table></figure><p>normal 模式下, 按<code>&lt;Leader&gt;x</code>, 等同于dd, 删除当前行.</p><p>此时, 另开一个文件, 执行同样的操作, 按<code>&lt;Leader&gt;x</code> , 没有变化.</p><p>Buffer-Local mappings 跟通用的 mappings 不一样的地方, 就是多了一个<code>&lt;buffer&gt;</code>, 也很好记.</p><p>需要稍稍注意的是, 当 buffer 与<code>&lt;Leader&gt;</code> 结合时, 建议使用 <code>&lt;LocalLeader&gt;</code> 来代替 <code>&lt;Leader&gt;</code>, 这样避免覆盖了他人的 <code>&lt;leader&gt;</code> mapping.</p><p>上面的例子建议改成:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;LocalLeader&gt;</span><span class="keyword">x</span> dd</span><br></pre></td></tr></table></figure><p>再看个例子:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> <span class="symbol">&lt;buffer&gt;</span> Q <span class="keyword">x</span></span><br><span class="line">:<span class="keyword">nnoremap</span>          Q dd</span><br></pre></td></tr></table></figure><p>normal 模式下, 按 Q, 发现执行的操作等同 x. 第二个 mapping 配置无效.</p><p>Buffer-Local mappings 会覆盖对应的通用的 mappings 配置.这点同 set options 不大一样, 待会会提到.</p></li><li><p>set options</p><p>基于 Buffer-Local 的设置, 用命令 <code>setlocal</code>.</p><p> 打开任意文件, 在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line">:<span class="keyword">setlocal</span> nonumber</span><br></pre></td></tr></table></figure><p>会发现行号已经消失.</p><p>需要注意的是, 如果 setlocal option 后, 又 set 了同一个 option, 则 setlocal 所做的改变会被覆盖.</p><p>比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">setlocal</span> nonumber</span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line">:<span class="keyword">setlocal</span> <span class="keyword">number</span>?</span><br></pre></td></tr></table></figure><p>此时输出的结果是 number.</p></li><li><p>abbreviations</p><p>同 mappings, Buffer-Local abbreviations 也只需要在<code>abbrev</code> 后, 添加一个<code>&lt;buffer&gt;</code>, 看个例子:</p><p>在当前打开的文件下, 命令行模式输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iabbrev</span> <span class="symbol">&lt;buffer&gt;</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>切换到 insert 模式, 输入log, 会替换成 logger.debug.</p><p>此时, 更换另一个文件, 再次在 insert 模式下, 输入log, 发现没有变化.</p><p>同 mappings 一样, Buffer-Local abbreviations 会覆盖通用的 abbreviations.</p><p>刚刚设置的文件中, 命令行模式输入:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">:iabbrev <span class="keyword">log</span> logger.<span class="keyword">info</span></span><br></pre></td></tr></table></figure><p>切换到 insert 模式, 输入log, 替换的仍然是 Buffer-local 设置的 logger.debug.</p></li></ul><p>OK. Buffer-Local 基本缕完, 下一章来点不一样的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章的内容结合了前面学到的知识.&lt;/p&gt;
&lt;p&gt;Buffer-Local, 顾名思义, 基于 Buffer,  只针对当前 Buffer 有效.&lt;/p&gt;
&lt;p&gt;前面遇到的 mappings, options , abbreviations, 当需要只对当前 Buffer 
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Abbreviations</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-abbrev/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-abbrev/</id>
    <published>2021-12-23T14:01:41.000Z</published>
    <updated>2021-12-23T14:05:29.705Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 的 Abbreviations 特性, 同 mappings 有些相似, 但是主要用于插入, 替换.</p><p>这里按照原书的思路简单说一下应用.</p><p>先来看个例子.</p><p>在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iabbrev</span> ned end</span><br></pre></td></tr></table></figure><p>然后在insert 模式下, 输入 ned 后回车或者退出insert 模式, 会发现 ned 已经变成了 end. [多嘴一句: 为什么是insert 模式下呢? 因为iabbrev 前面有个i….]</p><p>这个功能可以很方便纠正一些拼写错误.</p><p>鉴于我常常容易打出 ned, 所以我把这个 iabbrev 放在了 <code>.vimrc</code> 中. 哈哈.</p><p>不过需要注意的是, 用 abbreviation 替换的, 不可以是关键字 keyword, 包括所有的 ASCII 字符, 下划线(_)等.</p><p>可以通过<code>:h isfname</code> 来查看 Vim 中的所有关键字.</p><p>为了省去大伙看文档懵逼的时间, 作者在文中贴心地给了一个简单的记忆方法: 用 abbreviation 来替换的, 不可以是单个字母, 数字或者下划线.</p><p>说到这里, 你大概会猜, 支持扩展缩略的插件, 比如 <a href="https://github.com/mattn/emmet-vim">mattn/emmet-vim</a> 应该是 Abbreviations 的一个典型应用吧.</p><p>我当时就是这么想的, 屁颠屁颠跑去看 <a href="https://github.com/mattn/emmet-vim">mattn/emmet-vim</a> 的源代码想验证下猜想, 结果发现没有 iabbrev 的身影, 取而代之的是 substitute() 函数.🤪 [核心代码都是autoload目录下, 如果你也好奇的话….]</p><p>切回 Abbreviations.</p><p>如果想要清除刚刚的缩写设置, 可以使用:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:iunabbrev</span> ned</span><br></pre></td></tr></table></figure><p>如果想要清除所有的缩写设置, 可以使用:</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:abclear</span></span><br></pre></td></tr></table></figure><p>其中, <code>ab</code> 是 <code>abbrev</code> 的缩写形式….</p><p>上面 ned 那个例子里, 用mapping 也可以实现一样的功能.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:inoremap</span> ned <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那为什么不用 mapping呢?</p><p>因为 mappings 不会考虑需要替换的字符的上下文情况.[Mappings don’t take into account what characters come before or after the map]</p><p>作者在书中给了个例子. 但是这个例子很奇怪, inoremap 无效.</p><p>所以, 我来整了个简单点的.</p><p>在命令行模式下, 输入:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">inoremap</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>在 insert 模式下, 输入 log, log会自动更换成 logger.debug, 但是当你输入 blog 时, 发现也被自动替换成了blogger.debug.</p><p>这显然不是我们想要的.</p><p>换成 <code>iabbrev</code> 就可以避免这个坑.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">iunmap</span> <span class="built_in">log</span></span><br><span class="line">:<span class="keyword">iabbrev</span> <span class="built_in">log</span> logger.<span class="keyword">debug</span></span><br></pre></td></tr></table></figure><p>此处用 <code>iunmap</code> 来清除刚刚设置的mapping.</p><p>这时在 insert 模式下, 输入 blog, 发现不会被替换了.</p><p>Bravo~</p><p>OK, Abbreviations 可以告一段落. 自己试着写几个 abbrev 来帮助更正拼写吧😄️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vim 的 Abbreviations 特性, 同 mappings 有些相似, 但是主要用于插入, 替换.&lt;/p&gt;
&lt;p&gt;这里按照原书的思路简单说一下应用.&lt;/p&gt;
&lt;p&gt;先来看个例子.&lt;/p&gt;
&lt;p&gt;在命令行模式下, 输入:&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>editing your vimrc</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-edit-your-vimrc/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-edit-your-vimrc/</id>
    <published>2021-12-22T12:46:36.000Z</published>
    <updated>2021-12-23T08:17:28.375Z</updated>
    
    <content type="html"><![CDATA[<p>这一章结合前面所学的, 实现了两个功能: edit and source your vimrc.</p><p>当你编辑文件时, 如果想要修改 <code>.vimrc</code> 文件, 并使刚刚修改的配置生效, 有什么快捷的方式?</p><p>作者给了如下解决方法.</p><p>编辑<code>.vimrc</code>, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>ev :<span class="keyword">vsplit</span> $MYVIMRC<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">sv</span> :<span class="keyword">source</span> $MYVIMRC<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>其中, MYVIMRC 是Vim 提供的环境变量, 指的是 <code>.vimrc</code> 文件的位置, 可通过<code>:echo $MYVIMRC</code> 查看 MYVIMRC 的值.</p><p>这里提供了两个 mappings, 按<code>&lt;Leader&gt;ev</code> , 会打开一个新的split, 编辑  <code>.vimrc</code>  文件. 按<code>&lt;Leader&gt;sv</code> , source   <code>.vimrc</code>文件 .</p><p>不得不说, 真的超方便.</p><p>有了范例, 我也倒腾了一个编辑 <code>.tmux.conf</code> 的mapping.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>et :<span class="keyword">vsplit</span> $HOME/.tmux.<span class="keyword">conf</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>按<code>&lt;Leader&gt;et</code> , 编辑  <code>.tmux.conf</code>  文件.</p><p>同样也可以来个source:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">st</span> :!tmux <span class="keyword">source</span>-<span class="keyword">file</span> $HOME/.tmux.<span class="keyword">conf</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p> 但是通常需要 source  <code>.tmux.conf</code> 的场合, 也多是在 tmux 中, 直接快捷键 <code>Crtl-b + r</code> 就可以了.所以  source <code>.tmux.conf</code> 的这个 mapping 也可以不配置.</p><p>OK,  本章结束, 你也来配置个玩一玩吧^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章结合前面所学的, 实现了两个功能: edit and source your vimrc.&lt;/p&gt;
&lt;p&gt;当你编辑文件时, 如果想要修改 &lt;code&gt;.vimrc&lt;/code&gt; 文件, 并使刚刚修改的配置生效, 有什么快捷的方式?&lt;/p&gt;
&lt;p&gt;作者给了如下解决方法.
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Leaders</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-leaders/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-leaders/</id>
    <published>2021-12-21T13:10:12.000Z</published>
    <updated>2021-12-22T01:50:33.186Z</updated>
    
    <content type="html"><![CDATA[<p>来到了常见的 Leader.</p><p>初学时, 我简单地把 Leader 理解成一个 namespace, 好比 tmux 的 <code>Ctrl+b</code>. 现在看, 也没有偏差太多.</p><p>你可以把 Leader 看成是 Vim 内置的 prefix key.</p><p>Leader 的值存在 mapleader 变量中, 如果 mapleader 未初始化或者值为空, 则默认为 反斜杠 <code>\</code> .</p><p>这里注意: mapleader 是一个 variable, 不是一个 option, 使用 <code>:set mapleader?</code> 会报错的.</p><p>相应的, 如果想要修改 Leader 键, 可以通过给 mapleader 赋值来实现.</p><p>编辑<code>.vimrc</code>, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleader=<span class="string">&quot;-&quot;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>d dd</span><br></pre></td></tr></table></figure><p>保存退出, source 后, 打开文件, 在 Normal 模式下, 按 <code>-d</code>, 等同于执行 <code>dd</code>. 即删除当前行. 此时 <code>&lt;Leader&gt;</code> 已变成了<code>-</code> 了, 如果按<code>\d</code> , 会发现无效.</p><p>mapleader 还有一个小兄弟, 叫 maplocalleader,  在 Vim中用特殊的字符串 <code>&lt;LocalLeader&gt;</code> 来表示.</p><p>同样, 可以通过赋值 maplocalleader 来设置   <code>&lt;LocalLeader&gt;</code>  :</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">let</span> <span class="attr">maplocalleader</span> = <span class="string">&quot;\\&quot;</span></span><br></pre></td></tr></table></figure><p>那  <code>&lt;LocalLeader&gt;</code>  是用来干嘛的呢?</p><p>作者在书中提到  <code>&lt;LocalLeader&gt;</code>  用来作为特定文件类型中的前置键.</p><blockquote><p>This is meant to be a prefix for mappings that only take effect for certain types of files, like Python files or HTML files.</p></blockquote><p>这个同官方文档中给出的, 稍稍有些区别.</p><p>Vim 官方文档提到的是 <code>&lt;LocalLeader&gt;</code>  用于只针对当前 buffer 有效的mappings.</p><blockquote><p><code>&lt;LocalLeader&gt;</code>  is to be used for mappings which are local to a buffer.  Example:<br>:map <buffer> <code>&lt;LocalLeader&gt;</code>A  oanother line<Esc></p></blockquote><p>但是文档中也提到了:</p><blockquote><p>In a global plugin <code>&lt;Leader&gt;</code> should be used and in a filetype plugin <code>&lt;LocalLeader&gt;</code>.</p></blockquote><p>全局插件使用 <code>&lt;Leader&gt;</code>  , 特定文件类型的插件, 使用 <code>&lt;LocalLeader&gt;</code>  .[有关Plugin, 后面会单独再介绍]</p><p>当然, 平日里我基本用不到<code>&lt;LocalLeader&gt;</code> , 这里就不折腾了.</p><p>可以查看官方文档了解更多.</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:h</span> mapleader</span><br><span class="line"><span class="symbol">:h</span> maplocalleader</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来到了常见的 Leader.&lt;/p&gt;
&lt;p&gt;初学时, 我简单地把 Leader 理解成一个 namespace, 好比 tmux 的 &lt;code&gt;Ctrl+b&lt;/code&gt;. 现在看, 也没有偏差太多.&lt;/p&gt;
&lt;p&gt;你可以把 Leader 看成是 Vim 内置的 pref
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>mapping</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-mapping/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-mapping/</id>
    <published>2021-12-15T10:37:10.000Z</published>
    <updated>2022-01-11T08:06:06.155Z</updated>
    
    <content type="html"><![CDATA[<p>mapping  顾名思义, <code>map a b</code>, 当我执行 a 操作时, 它会做 b 操作会做的事.</p><p>看个例子, 在 Vim 命令行中, 输入:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">map</span> <span class="string">\</span> dd</span><br></pre></td></tr></table></figure><p>表示, 在 normal 模式下, 按下<code>\</code>, 就会删除当前光标所在的行.</p><p>mapping的设置, 跟模式有关系.</p><p><code>nmap</code> : normal mode 下的 mapping, 只在 normal 模式下有效.</p><p><code>vmap</code> : visual mode 下的 mapping, 只在 visual 模式下有效.</p><p><code>imap</code> : insert mode 下的 mapping, 只在 insert 模式下有效.</p><p><code>omap</code> : operator-pending mode 下的 mapping, 只在 operator-pending 模式下有效.</p><p><code>map</code>: normal, visual, operating mode 下的 mapping, 在 normal/visual/operator-pending 模式下有效.</p><p>map 有一个大坑, 叫做 Recursion, 书中给了一个例子, 比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nmap</span> dd O<span class="symbol">&lt;esc&gt;</span>jddk</span><br></pre></td></tr></table></figure><p>normal 模式下, 按下dd, 等同于执行了<code>O&lt;esc&gt;jddk</code> , 而 <code>O&lt;esc&gt;jddk</code> 也有 <code>dd</code>, Vim 就会再次 mapping, 如此无穷尽….</p><p>解决方法是使用<code>noremap</code>,  nonrecursive mapping. 修改上面那个命令:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> dd O<span class="symbol">&lt;esc&gt;</span>jddk</span><br></pre></td></tr></table></figure><p>这样就正常了. 鉴于 noremap 能避雷,  作者给到的意见时, <strong>Always</strong> using  noremap instead of map. </p><p>再看个例子:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:nnoremap</span> &lt;C-s&gt;  <span class="symbol">:suspend&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><p>上述命令表示, normal 模式下, 按住 Ctrl + s, 就等同于在命令行输入了<code>:suspend</code> 然后回车 ,这里  <code>&lt;CR&gt;</code> 表示Enter回车键.</p><p>都说到<code>&lt;CR&gt;</code> , 不妨来看看 VimScript 中 的 一些常用的 keycodes :</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">&lt;Esc&gt;</span> : 代表 Esc 键</span><br><span class="line"><span class="attribute">&lt;C-&#123;key&#125;&gt;</span> : Ctrl + 任意键, 通常是字母键</span><br><span class="line"><span class="attribute">&lt;S-&#123;key&#125;&gt;</span> : Shift + 任意键, 通常是字母键</span><br><span class="line"><span class="attribute">&lt;CR&gt;</span> : Enter键,也可以用<span class="attribute">&lt;Enter&gt;</span>, <span class="attribute">&lt;Return&gt;</span> 来表示</span><br><span class="line"><span class="attribute">&lt;Space&gt;</span> : 空格键</span><br><span class="line"><span class="attribute">&lt;Leader&gt;</span> : Leader 键</span><br><span class="line"><span class="attribute">&lt;Left&gt;</span> : 左移方向键, 类似有<span class="attribute">&lt;Right&gt;</span>, <span class="attribute">&lt;Up&gt;</span>, <span class="attribute">&lt;Down&gt;</span></span><br></pre></td></tr></table></figure><p>那么, 如何知道 VimScript 中所有 key 的特殊标记? 用万能的<code>:help</code>  就好了, 命令行输入:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:h</span> key-notation</span><br></pre></td></tr></table></figure><p>可以查看所有的 key-notation.</p><p>我还记得刚入门时, 有时候看到别人的 vimrc 文件中, 有些 keycode 是全部小写的, 比如 <code>&lt;cr&gt;</code>, <code>&lt;esc&gt;</code>, 当时觉得, 有的人大写, 有的人小写, 哪种才是规范的呢? 直到看了文档, 才知道官方是首字母大写, 也算解了我的一个小困惑.</p><p>Vim 中有个特殊的 mapping, <code>&lt;Nop&gt;</code>, 表示什么也不做. 比如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">inoremap</span> <span class="symbol">&lt;Esc&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br></pre></td></tr></table></figure><p>Insert 模式下, 按下 Esc 键, 什么也没有做. [慎用!!!]</p><p>现在, 我们可以用学到的知识来写个简单的禁止使用上下左右键的功能:</p><p>在 <code>.vimrc</code> 文件中, 添加如下代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; disable up, down, leaf, right</span></span><br><span class="line"><span class="comment">&quot; normal mode</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; visual mode</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; insert mode</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Up&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Down&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Left&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;Nop&gt;</span></span><br></pre></td></tr></table></figure><p>这样就只能用 hjkl 了.</p><p>好了, 除了 Operator-Pending Mappings 外, 基本算是缕清了, 整点好吃的, 犒劳下自己吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mapping  顾名思义, &lt;code&gt;map a b&lt;/code&gt;, 当我执行 a 操作时, 它会做 b 操作会做的事.&lt;/p&gt;
&lt;p&gt;看个例子, 在 Vim 命令行中, 输入:&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>set option</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-set-option/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-set-option/</id>
    <published>2021-12-15T10:36:51.000Z</published>
    <updated>2021-12-22T01:50:17.426Z</updated>
    
    <content type="html"><![CDATA[<p>新手基本都会在大佬们的.vimrc 文件中看到不少 set option. </p><p>我们可以把 option 看作是 built-in configuration.</p><p>option 可以是布尔值, 类似开关, <code>set &#123;option&#125;</code>, <code>set no&#123;option&#125;</code>, 也可以赋值 <code>set &#123;option&#125;= &#123;value&#125;</code>. 以 number 为例:</p><p>在 Vim 命令行中, 输入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出 number 的当前值</span></span><br><span class="line">:set number?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加行号显示</span> </span><br><span class="line">:set number</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭行号显示, 通用模式no&#123;option&#125;</span></span><br><span class="line">:set nonumber</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换</span></span><br><span class="line">:set number!</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置成默认值</span></span><br><span class="line">:set number&amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置所有的 option 为系统默认值</span></span><br><span class="line">:set all&amp;</span><br></pre></td></tr></table></figure><p>这里简单提一下, 比较常用的 path. </p><p>在 Vim 命令行中, 输入当前Path:</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> <span class="built_in">path</span>?</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code> path=.,/usr/include,,</code></p><p>其中:</p><ul><li><p>. 指的是当前打开文件所在的目录.</p></li><li><p>/usr/include 是 C Libraries 头文件目录</p></li><li><p>, 指得是当前目录</p></li></ul><p>建议将经常访问的目录添加到 path, 比如:</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> path+=app/<span class="keyword">models</span>/</span><br></pre></td></tr></table></figure><p>这样就用<code>find</code> 就顺手多了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新手基本都会在大佬们的.vimrc 文件中看到不少 set option. &lt;/p&gt;
&lt;p&gt;我们可以把 option 看作是 built-in configuration.&lt;/p&gt;
&lt;p&gt;option 可以是布尔值, 类似开关, &lt;code&gt;set &amp;#123;option
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>echo vs echom</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-on-echo/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-on-echo/</id>
    <published>2021-12-15T10:32:36.000Z</published>
    <updated>2021-12-22T02:27:20.426Z</updated>
    
    <content type="html"><![CDATA[<p>echo 和 echom 都用于输出, 但是 echom 输入的内容, 会被保存在 messages 中.</p><p>在 Vim 命令行中, 输入:</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:echo</span> <span class="string">&quot;hello, world through echo&quot;</span></span><br><span class="line"><span class="symbol">:echom</span> <span class="string">&quot;hello, world through echom&quot;</span></span><br><span class="line"><span class="symbol">:messages</span></span><br></pre></td></tr></table></figure><p>可以在 messages 中看到 echom 输出的内容.</p><p>我之前会觉得 echo 没啥用, 直到看到 Max Cantor 的一个分享视频 <a href="https://www.youtube.com/watch?v=XA2WjJbmmoM&list=WL">How to Do 90% of What Plugins Do (With Just Vim)</a> , 他当时尝试用  <code>:echo expand(&#39;%&#39;)</code> 输出当前文件的相对路径, 看到结果的那一刻,  Max 情不自禁 yes了一下, 那个开心啊, 多像跑通代码的我们, 一下子让我记住了expand(“%”), 也对echo 有了印象……..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;echo 和 echom 都用于输出, 但是 echom 输入的内容, 会被保存在 messages 中.&lt;/p&gt;
&lt;p&gt;在 Vim 命令行中, 输入:&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>前言</title>
    <link href="http://lupeipei.github.io/posts/vimscript-learning-preface/"/>
    <id>http://lupeipei.github.io/posts/vimscript-learning-preface/</id>
    <published>2021-12-15T10:26:07.000Z</published>
    <updated>2021-12-22T01:50:23.869Z</updated>
    
    <content type="html"><![CDATA[<p>这里是刷 <a href="https://github.com/sjl">Steve Losh</a>的  <a href="https://learnvimscriptthehardway.stevelosh.com/">Learn Vimscript the Hard Way </a> 的笔记系列.</p><p>写之前特意查了下, 已经有网友将本书翻译成了中文, 但主页已经打不开, 倒是在看云上保留了原来的译文, 如果想阅读中文版本, 这里附上<a href="https://www.kancloud.cn/kancloud/learn-vimscript-the-hard-way/49321">链接</a>.</p><p>当然, 个人非常推荐阅读原文, 50多篇, 每篇篇幅都比较短, 阅读过程中, 作者还会偶尔来点调皮话, 整点哲理鸡汤啥的, 叫人读着读着就笑了, 哈哈…..</p><p>总之, 阅读原版是一件很开心的事情, 不要让自己错过.&gt;^.^&lt;</p><p>鉴于我自己也是一个Vim 新手, 所以我多是以我个人的理解去对书中的内容做一些整理, 偶尔加点新东西, 同时尽量顺着原作者的写作风格, 力求简明清晰说人话, 篇幅适中易阅读, 达到入门 VimScript 的目标.</p><p>本文适合有 Vim 使用经验(至少 Vim 使用一两个月) 的新手围观.</p><p>原书基于Vim 7.3,  本系列基于 Vim 8.2. 某些内容会与原文稍有差异.</p><p>开始吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是刷 &lt;a href=&quot;https://github.com/sjl&quot;&gt;Steve Losh&lt;/a&gt;的  &lt;a href=&quot;https://learnvimscriptthehardway.stevelosh.com/&quot;&gt;Learn Vimscript the Hard
      
    
    </summary>
    
      <category term="VimScript 学习笔记" scheme="http://lupeipei.github.io/categories/VimScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>读 《Man&#39;s Search For Meaning》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-man-s-search-for-meaning/"/>
    <id>http://lupeipei.github.io/posts/notes-of-man-s-search-for-meaning/</id>
    <published>2021-12-09T06:56:15.000Z</published>
    <updated>2021-12-12T02:18:52.634Z</updated>
    
    <content type="html"><![CDATA[<p>拖了近半年, 趁着休假, 整理了下.</p><span id="more"></span><p>整本书篇幅很短, 分两部分.</p><p>第一部分 Experiences in a concertration Camp 讲述了作者本人在集中营的那段经历.</p><p>第二部分 Logotherapy in a Nutshell,  作者简单介绍了他创立的心理治疗理论 logotherapy, logo 在希腊语中指 meaning. 该理论也基于他本人在集中营的那段经历.</p><p>我一直觉得只要人活着, 某些经历是无法遗忘的, 更何况是被囚禁在集中营. 你以为时间会帮你淡忘, 你选择不再记起, 但它们是你过去的一部分, 这是不争的事实, 看似忘却, 但其实从未离开. 书中也提到那些从集中营走出来的人, 大部分都有着或多或少的后遗症, 而作者作为亲历者之一,  选择将苦难化作了养分, 通过创作去疗愈心理创伤. 一定意义上, 感觉更像是自救, 而整个过程, 却也治愈了其他人.</p><p>切合了古语, 自渡者渡人.</p><p>那整本书, 作者想要表达的是什么呢?</p><p>在书的前言部分, 基本点出了整本书他想要表达的观点.</p><blockquote><p>Life is not primarily a quest for pleasure, or a quest for power, but a quest for meaning.</p><p>Viktor Frankl saw three possible sources for meaning:</p><ul><li>in work</li><li>in love</li><li>in courage during difficult times</li></ul></blockquote><p>作者认为, 人生不是追逐名利与欢愉, 而是追求意义. 而意义有三个可能的来源, 工作, 爱, 困境中的勇气.</p><p>作者为什么会认为追求 meaning 很重要?</p><blockquote><p>因为它会支撑着一个人走过那些煎熬的日子, 而不是在困境中, 选择通过结束生命, 来结束痛苦.</p><p>书中多次引用了尼采 Nietzsche 的话: <strong>He who has a Why to live for can bear almost any How.</strong></p><p>meaning 就是那个 Why.</p></blockquote><p>但是人是多样的, 对于每个人来说, 人生的意义自然也千差万别.</p><p>甚至, 是否应该去追求人生的意义 , 也完全是个人的选择.</p><p>值得一提的是, 作者并没有去歌颂苦难, 而是强调在无法避免的苦难中, 赋予人生以意义, 找到支撑人活下去的信念, 改变态度, 转移焦点, 人才能在苦难中更好地生存下去.</p><p>同时, 他也强调, 不要把人生的目标放在成功和幸福上, 它们只是 meaningful life 中的 by-product:</p><blockquote><p>Don’t aim at success—the more you aim at it and make it a target, the more you are going to miss it. For success, like happiness, cannot be pursued; it must ensue, and it only does so as the unintended side-effect of one’s dedication to a cause greater than oneself or as the by-product of one’s surrender to a person other than oneself. Happiness must happen, and the same holds for success: you have to let it happen by not caring about it. <strong>I want you to listen to what your conscience commands you to do and go on to carry it out to the best of your knowledge.</strong> Then you will live to see that in the long run—in the long run, I say!—success will follow you precisely because you had forgotten to think of it.</p></blockquote><p>这倒让我想到 John Roberts 在他那篇很出彩的演讲 I wish you bad luck 里面提到的:</p><blockquote><p>…..And <strong>one important clue to living a good life is to not to try to live the good life</strong>. The best way to lose the values that are central to who you are is frankly <strong>not to think about them at all</strong>.</p></blockquote><p>刻意追求的反而得不到.</p><p>大抵真正重要的东西, 莫不如此.</p><p>这样想, 人生某种程度上是公平的.</p><p>Seeing the message in your misfortunes and benefit from them.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖了近半年, 趁着休假, 整理了下.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>新手入坑Vim</title>
    <link href="http://lupeipei.github.io/posts/vim-tips-and-tricks/"/>
    <id>http://lupeipei.github.io/posts/vim-tips-and-tricks/</id>
    <published>2021-12-07T08:37:32.000Z</published>
    <updated>2021-12-07T08:45:21.293Z</updated>
    
    <content type="html"><![CDATA[<p>本文对 Vim 新手有一些帮助, 高手请忽略.</p><span id="more"></span> <p>之前一直使用 Atom 搭配 Vim 模式来工作, 前段时间彻底跟  Atom 拜拜, 重新配置了 Vim,用了一段时间, 渐渐习惯. 这里记录下使用过程中的一些感受和小技巧, 方便新手快速入坑.</p><p>本文基于 Vim 8.2.</p><h4 id="配置vimrc"><a href="#配置vimrc" class="headerlink" title="配置vimrc"></a>配置vimrc</h4><p>大部分新手一上来多是刷大牛们的<code>.vimrc</code>配置, 然后直接用, 把vim配置得非常 Modern, 我初来也是, 甚至连里面很多配置的语法都不大懂, 一上来什么都不管, 一顿瞎操作, 能用就行. 只能说 Copy + Paste 懒人模式害人不浅啊. 后面慢慢摸出感觉, 砍掉了很多插件, 只留下自己看得懂, 常用到的.</p><p>建议新手只配置一些简单的,  后面有需要再慢慢添加, 多看文档, 确保你知道安装的插件是用来做什么的.</p><p>一些常用插件:</p><ul><li><p><a href="https://github.com/tpope/vim-commentary">tpope/vim-commentary</a></p></li><li><p><a href="https://github.com/tpope/vim-surround">tpope/vim-surround</a></p></li><li><p><a href="https://github.com/preservim/nerdtree">preservim/nerdtree</a></p></li><li><p><a href="https://github.com/mattn/emmet-vim">mattn/emmet-vim</a></p></li></ul><p>主题系列, 推荐 <a href="https://github.com/vim-airline/vim-airline">vim-airline/vim-airline</a> 搭配 <a href="https://github.com/vim-airline/vim-airline-themes">vim-airline/vim-airline-themes</a></p><p>有关语言的插件, Github 自行搜索 vim-[language], 比如 vim-ruby, vim-go…..</p><h4 id="一些指令操作与技巧"><a href="#一些指令操作与技巧" class="headerlink" title="一些指令操作与技巧"></a>一些指令操作与技巧</h4><p>基本操作, 光标移动hjkl之类, 这里就略过了.简单提一些其他的操作指令.</p><p>保存并退出Vim:</p><blockquote><p>除了<code>:wq</code>, 还可以 ZZ (shift+z 两次) </p></blockquote><p>返回 Normal mode :</p><blockquote><p>除了常见的 <code>esc</code>, <code>Ctrl-[</code>, <code>Ctrl-c</code> 也可以.</p></blockquote><p>打开文件:</p><blockquote><p>最简单的是: <code>vim .</code>  打开当前目录, 或者 <code>vim file</code> 打开文件.</p><p>Vim 命令本身可以接受参数, 比如 <code>+&#123;cmd&#125;</code> 或者 <code>-c &#123;cmd&#125;</code> , 打开文件并执行相应命令.</p><pre><code class="shell">vim +&#123;cmd&#125; filevim -c &#123;cmd&#125; file</code></pre><p>这里的cmd 指的是在命令行模式下的命令, 比如打开文件 <code>text.txt</code> 并跳转到第10行:</p><pre><code class="shell">vim +10 text.txtvim -c 10 text.txt</code></pre><p>命令行模式下打开文件:</p><p>推荐用<code>:e xxx </code>,   同时结合 <a href="https://github.com/preservim/nerdtree">preservim/nerdtree</a> , 可以打开文件<code>:e file </code>, 也可以打开目录<code>:e folder </code>, 基本满足需求.</p></blockquote><p>无插件下查找文件:</p><blockquote><p>使用自带的 <code>find</code>, 记得搭配 set path , 设置好需要查找的目录, 同时巧用Tab 键补全. 比如:</p><pre><code>:set path+=app/models/:find tes&lt;Tab&gt;</code></pre></blockquote><p>搜索与替换:</p><blockquote><p>搜索: </p><p>在当前文件中搜索, 使用自带的<code>/content</code>,   <code>? content</code> </p><p>全文搜索, 建议用插件吧, 推荐 <a href="https://github.com/eugen0329/vim-esearch">eugen0329/vim-esearch</a>, 我自己用起来目前觉得够用,顺手.如果非要用自带的<code>:vim </code> 或者 <code>:grep</code> 可能导致弃坑…..</p><p>替换:</p><ul><li><code>:s/pattern/replace/g</code> - 全局替换当前行所有匹配.</li><li><code>:%s/pattern/replace/g</code> - 全局替换当前文件所有匹配.</li><li><code>:%s//replace/g</code> - 全局替换当前文件最后一次搜索结果.</li></ul></blockquote><p>撤销与反撤销</p><blockquote><p>u 撤销(Undo), 如果需要撤销刚刚的撤销操作 (Redo), 使用 <code>Ctrl-r</code></p></blockquote><p>Tab 创建与切换:</p><blockquote><p><code>:tabnew file</code> : 在新的 tab 中打开文件</p><p>打开文件时, 开多个tabs, 可以用:<code>vim -p file1 file2</code></p><p>跳转到 下一个 tab 用 <code>gt</code>, 前一个 tab 用 <code>gT</code></p></blockquote><p>窗口拆分与切换:</p><blockquote><p>Ctrl-w + n: 拆分窗口, 新增窗口</p><p>Ctrl-w + s:  将当前窗口分成水平窗口</p><p>Ctrl-w  + v: 将当前窗口分成竖直窗口</p><p>Ctrl-w + q /  c :  退出/关闭 当前窗口</p><p>Ctrl-w + h/j/k/l:  窗口左右上下切换</p></blockquote><p>Buffer切换:</p><blockquote><p><code>:bn</code> 切换到下一个buffer</p><p><code>:bp</code>切换到前一个buffer</p><p><code>:bd</code>  删除当前buffer, 可以<code>:bd + &#123;BufferNumber&#125;</code>, 删除指定 bufferNumber 的Buffer.</p><p>命令行使用<code>:ls</code> 列出buffer 列表, 如何去对应的Buffer?</p><p><code>:buffer + &#123;BufferNumber&#125;</code>  或者按键 bufferNumber  + <code>Ctrl-^</code>, 去指定 bufferNumber的Buffer.</p><p> <code>Ctrl-^</code> 也可以用来返回前一个编辑的buffer.</p></blockquote><p>Vim 和 终端切换:</p><blockquote><p>挂起Vim的三种方法:</p><ul><li><code>:suspend</code> </li><li><code>:stop</code>  </li><li>Ctrl-z</li></ul><p>终端输入: fg&lt;cr&gt; 返回到Vim. (&lt;cr&gt; 指 Enter键)</p></blockquote><p>执行命令:</p><blockquote><p><code>:!cmd</code>  其中 cmd 为 shell 命令.</p><p>对文件的操作, 可以考虑安装 <a href="https://github.com/tpope/vim-eunuch">tpope/vim-eunuch</a> 试试.[vim-eunuch 偶尔会让人抓狂..]</p></blockquote><p>屏幕刷新恢复:</p><blockquote><p>如果一顿操作后, 整个屏幕黑了(sooner or later….), 使用 <code>Ctrl+l</code>  或者命令 <code>:redraw</code>,  甚至强制刷新 <code>:redraw!</code>  回到现实. </p></blockquote><p>vim 文档阅读:</p><blockquote><p><code>:h(elp) &#123;content&#125;</code>  {content} 为需要搜索的内容.</p><p>比如 <code>:h i_CTRL-P</code> 查看 Insert 模式下 Ctrl-P 做什么. 如果查看Normal 模式下Ctrl-P 做什么, 用 <code>:h CTRL-P</code> </p><p>阅读文档时, 如何跳转?</p><p><code>Ctrl-]</code> 跳转到光标对应的文档</p><p><code>Ctrl-o</code> 返回上一个位置</p></blockquote><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Enjoy.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对 Vim 新手有一些帮助, 高手请忽略.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://lupeipei.github.io/categories/CS/"/>
    
    
      <category term="Vim" scheme="http://lupeipei.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>读《一间只属于自己的房间》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-a-room-of-ones-own/"/>
    <id>http://lupeipei.github.io/posts/notes-of-a-room-of-ones-own/</id>
    <published>2021-10-15T09:32:16.000Z</published>
    <updated>2021-10-15T09:35:55.949Z</updated>
    
    <content type="html"><![CDATA[<p>将近一个世纪前的作品.</p><span id="more"></span><p>读完这本书后, 去了解了作者伍尔夫的生平, 不得不感叹, 真的是名奇女子.</p><p>书中的某些建议, 放在今天, 依然非常中肯.</p><blockquote><p>一个女人如果要写小说，那么她必须拥有两样东西，一样是金钱，另一样是一间自己的房间。</p><p>我希望，大家无论通过什么方法，都能挣到足够的钱，去旅行，去闲着，去思考世界的过去和未来，去看书做梦，去街角闲逛，让思绪的钓线深深沉入街流之中。</p><p>我想说的很简单、很平淡：没有什么比做自己更重要。</p></blockquote><p>看有些书评, 说这本书是女权运动和女性主义理论史上最具影响力的著作之一. 本人读书少, 读女性方面的书更少, 只觉得这本书确实很值得女性去阅读.</p><p>毕竟现实不会因为你是女性而区别对待.</p><p>现实就是, 你没有臂膀可以依靠，只能自己前进.</p><p>如同书中所说的, 人与人的关系, 不仅仅是男人和女人之间的关系，也是人和真实世界的关系.</p><p>细想一下, 如果伍尔夫生前没有显赫的家世, 没有遇到理解她, 尊重她的丈夫伦纳德, 她大概率也不会有一间可以上锁的房间, 有充足的时间去思考, 去写作, 继而成为享有声誉的现代主义作家.</p><p>艺术可能不那么需要钱, 但一定需要闲.</p><p>她是幸运的.</p><p>玩偶之家的故事不会在她身上上演.</p><p>但她也是不幸的, 童年的阴影伴随了她的一生.</p><p>除了一些对女性的建议, 书中作者对于写作的一些观点也有些新颖, 我从来没去想过, 文字会出卖写作者.</p><p>文字是写作者表达自我的一种方式.</p><p>好的文字里, 没有取悦, 没有讨好, 没有说教, 没有憎恨, 没有抗议.</p><p>好的文字, 需要写作者内心平静.</p><p>这样看来, 金钱和房间, 在某种程度上, 为写作者的内心平静提供了物质基础.</p><p>其实不管女性是否写作, 物质基础都很重要. 拥有自己的房间, 意味着你能有属于自己独立的时间和空间, 而独处, 不管对于男性还是女性, 都是重要的精神养分.</p><p>写到这里,  我内心的OS只有一个: 好好赚钱啊💰️.</p><p>另一个稍微意外的地方与书无关, 是被伍尔夫的容貌稍稍惊艳到.</p><p>真正一枚明明可以靠颜值, 偏偏要靠才华的女子.</p><p>记得看伍尔夫的生平往事时, 有的文章提到了伦纳德第一次见到伍尔夫的场景, 当时的她, 身穿一袭白裙、手持阳伞, 初见她的这位少年, 平静的心不禁掀起了波澜, 这才有了后来的不离不弃, 相伴余生.</p><p>附上一张20岁的伍尔夫:</p><p><img src="https://raw.githubusercontent.com/Lupeipei/blogImages/master/images336.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将近一个世纪前的作品.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>读《重来3》</title>
    <link href="http://lupeipei.github.io/posts/notes-of-it-does-not-have-to-be-crazy-at-work/"/>
    <id>http://lupeipei.github.io/posts/notes-of-it-does-not-have-to-be-crazy-at-work/</id>
    <published>2021-09-07T06:56:02.000Z</published>
    <updated>2021-09-07T06:57:27.821Z</updated>
    
    <content type="html"><![CDATA[<p>《重来3》中文版部分内容摘选.</p><span id="more"></span><p>长期的疲惫不是荣誉勋章，而是愚蠢的标志。</p><h4 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h4><p>我快忙疯了(it’s crazy at work)</p><blockquote><p>对许多人来说，“快忙疯了”已经成了他们的日常。可是，为何要这么疯狂？</p><p>主要原因有二：</p><ul><li>一是工作时间被各种或真实或虚拟的东西干扰，被切割得七零八碎；</li><li>二是不惜任何代价追求成长，这种不健康的执念促使人们设下不切实际的期望，把他们压迫得疲惫不堪。</li></ul><p>超长的工作时间里面, 大部分时间都被浪费了.</p><p>解决方案不是多花时间，而是少扯淡；是减少浪费，而不是增加投入。</p><p>在Basecamp,  我们不要不惜代价的成长，不要徒劳无功的忙碌。我们不设被好胜心驱使的目标，不跟同类型的公司攀比。我们不把自己逼到火烧眉毛的境地。</p><p>总体上来说，<strong>我们是冷静的——这是刻意的选择</strong>，也是亲身践行的结果。</p></blockquote><p>你的公司是个产品</p><blockquote><p>一切始于这个概念：你的公司是个产品。</p><p>你做出来的东西叫作产品（或服务），但它是经由你的公司做出来的。正是因为这个原因，你的公司应该是你最棒的产品。</p><p>本书的一切观点都围绕着这个主题延展开来。就像产品需要不断改良一样，公司也需要迭代才能不断进步。如果你想把一个产品做得更好，就必须不断地测试、修改、迭代。做公司也是一样。</p><p>做项目的时候，我们会<strong>集中工作6周</strong>，接下来的两周就脱离固定的时间表，“自由散漫”地工作，给自己减减压。</p></blockquote><h4 id="抑制你的野心"><a href="#抑制你的野心" class="headerlink" title="抑制你的野心"></a>抑制你的野心</h4><p>拒演“拼命工作”的苦情戏</p><blockquote><p>你并不会因为牺牲了一切而变得更有价值。</p><p>生命远不只是连轴转和忙到极限，人类的体验远比这辽阔、丰富得多。</p><p>充实地好好干上一天活儿，日复一日，这就足够了。</p><p>你可以拥有个人爱好，你可以好好照顾自己的身体，你可以坐下来好好读本书，你可以跟另一半一起看一部傻乎乎的电影，你可以抽出时间来做一顿像样的饭菜，你可以出门去散个长长的步。你可以时不时地，敢于做一个彻底的普通人。</p></blockquote><p>做个快乐的和平主义者</p><blockquote><p>我们为和平而来，我们没有建造帝国的野心，我们没想着要统治某个行业、某个市场。我们希望人人都能活得好好的，我们也有自己想追求的东西，但犯不着去抢夺别人的。</p><p>我们为顾客提供满意的服务，他们也给我们带来满意的回报，这才是真正重要的事。</p><p>在Basecamp，没有你追我赶，没有兔子要逮，只有因干出了最漂亮的活儿而得到的深深的满足感。衡量的标准就是我们自己的幸福感，以及顾客的购买量。</p><p>成为市场中的诸多选择之一，是一种美德——因为你的存在，顾客多了一个实实在在的选择。</p></blockquote><p>我们的目标是：没有目标</p><blockquote><p>我们当然懂，<strong>我们明白商业世界的运作规律——我们只是不在乎它</strong>。我们不介意在桌上留下点钱，也没必要把柠檬里的每一滴汁水都挤干榨净，反正最后的那几滴果汁总是酸涩的。</p><p>让我们直面真相吧：目标是个虚假的东西。几乎所有的目标都是为了设定而设定的。</p><p><strong>让公司生存下去，好好服务顾客，或者成为一个能让员工开开心心来上班的地方。这些目标不太容易量化，但并不等于它们不重要。</strong></p></blockquote><p>别总想着改变世界</p><blockquote><p>踏踏实实地干出漂亮活儿，跟顾客、员工和现实世界打交道时做到公平正直，给跟你打交道的人留下一个深刻的印象，少操心改变世界的事儿.</p></blockquote><p>边走边摸索</p><blockquote><p>长期计划会让人产生一种虚假的安全感。</p><p>要想把舵掌稳，那就在前行中及时做出微调，一千次也不怕，这肯定比一上来就猛打几次舵轮强得多。</p><p>每隔6周，我们会决定下一步要做什么，这就是我们唯一的计划。</p><p><strong>关于决策，你能掌握的最佳信息是在执行的时候获得的</strong>。我们等待这样的时刻来做出明智的决定。</p></blockquote><p>舒适环境有什么错？</p><blockquote><p>待在自己的舒适区里，是保持冷静的必要条件。[这段很非主流].</p><p><strong>对我们来说，见效的往往不是向外突破，而是潜心向内，去深挖，留在那个能带来最大收益的兔子洞里。</strong></p><p>在绝大多数情况下，如果某样东西令你感到不舒服，那正是因为它不对劲。如果你渐渐习惯于压抑一切不舒服的感受，你必将失去自己，也将失去你的道德准则。[有些类似心理学上的, 重视你的负面感觉, 它们在告诉你一些重要的信息]</p></blockquote><h4 id="捍卫你的时间"><a href="#捍卫你的时间" class="headerlink" title="捍卫你的时间"></a>捍卫你的时间</h4><p>40小时足矣</p><blockquote><p>每周工作40小时就足够了。足够你干出优质的活儿，足够你保持竞争力，足够你把重要的事情做完。</p><p>如果按照每周40小时的步调，<strong>你想做的事情做不完，那么你需要锻炼自己的选择能力</strong>，把真正该做的事情挑选出来，而不是延长工作时间。</p></blockquote><p>保护主义</p><blockquote><p>在Basecamp，<strong>我们把保护员工的时间和注意力视作最重要的责任。</strong></p><p>时间和注意力最好是大笔大笔地花出去，而不是换成零钱或硬币，散碎地用——把大块时间用在高价值的、缜密的工作上。</p></blockquote><p>高质量的1小时</p><blockquote><p><strong>仔细审视一下自己的时间。</strong>如果你的时间都是零碎的小段，是谁，或什么原因把它切分成了这样？是其他人在干扰你，还是你在干扰自己？你能做出哪些改变？</p><p>问问自己：上次你能把完全不受干扰的3个甚至4个小时留给自己和工作，是什么时候？</p></blockquote><p>高效比高产更重要</p><blockquote><p>高产指的是把时间全部占上——把时间表填到不能更满，然后尽你所能，做得越多越好。</p><p>而高效指的是<strong>找出更多未被侵占的时间，留给工作之外的其他事</strong>——留给休闲放松，留给家人和朋友，或者留出时间，什么也不干。</p><p><strong>利用时间的一个妙招就是，不做不值得做的事。</strong></p></blockquote><p>比别人更努力，就能出类拔萃？</p><blockquote><p>职业道德指的是做一个<strong>本质上的好人</strong>：<strong>值得他人信赖，是令人愉快的工作伙伴</strong>。</p><p>良好的职业道德指的<strong>不是随叫随到</strong>，而是<strong>说到做到、踏踏实实地做好每一天的事</strong>。</p><p><strong>把“比别人更努力”的念头从脑子里清除出去吧。</strong></p><p><strong>别再把职业道德跟超长的工作时间画等号</strong>。它既不能帮你领先一步，也不能帮你冷静下来。</p></blockquote><p>俄罗斯方块</p><blockquote><p><strong>不共享日程表.</strong></p><p>在Basecamp，要想看到别人的日程表，你得跟人家直接协商，这可是个漫长的谈判过程，不是唾手可得的便利。</p><p>如果你对自己的大多数时间都掌控不了，那你就不可能冷静下来。你会经常感到压力，觉得自己安心做事的能力被人夺走了。</p><p>当某人把时间从你手中夺走的时候，就相当于毁掉了你“踏踏实实地工作了一天”的成就感啊。真正取得进展才会让人感到由衷的满足。</p></blockquote><p>即时回复</p><blockquote><p>对即时回复的期待犹如一根导火索，引发了太多的险情。</p><p>在绝大多数情况下，对即时回复的期待都是毫无道理的。</p><p><strong>几乎所有的事情都可以等。几乎所有的事情都应该等。</strong></p></blockquote><p>错失良机恐惧症</p><blockquote><p>一边儿去吧。错过了有什么大不了的！在绝大多数时间里，绝大多数人就是会错过绝大多数事情啊。在Basecamp，我们倡导人们坦然面对它。别再担忧错失机缘了，淡定些！</p><p>有了淡定的心态，你就会关掉源源不断的信息流，关掉聊天工具，把各种干扰拒之门外，安安心心地把你该做的事做好。</p><p>我们希望员工能体验到那种静谧的、笃定的、因专注而生的快乐。</p></blockquote><h4 id="培养企业文化"><a href="#培养企业文化" class="headerlink" title="培养企业文化"></a>培养企业文化</h4><p>我们不是一家人</p><blockquote><p><strong>有的公司喜欢宣扬“我们都是一家人”。不，你们不是。</strong></p><p><strong>最优秀的企业不是家庭。它们是家庭的后盾，是家庭的同盟军。</strong>它们提供健康的，能让人找到成就感的工作环境，让员工能在合理的时间合上笔记本电脑，去做最好的丈夫、妻子、父母、手足和孩子。</p></blockquote><p>榜样的力量</p><blockquote><p>一个树立了自我牺牲的榜样的领导者，必定也会要求他人自我牺牲。[严于律己的, 往往很难宽以待人]</p><p>工作狂是一种传染病。</p></blockquote><p>信任犹如电池</p><blockquote><p>还有一个我们经常谈论的概念叫作信任电池。当员工刚进公司时，这个电池的电量是50%。此后，你每跟他打一次交道，你们之间的这节信任电池就要么充电，要么耗电，具体取决于你是否能兑现承诺的事。</p><p>信任电池的电量是过往一切互动结果的总和。</p><p><strong>信任电池的电量太低，正是工作中人际冲突的症结所在。</strong></p><p>要想在工作中拥有良好的人际关系，那就得<strong>用心经营</strong>。唯有当你坦诚地面对关系的真实现状，你的努力才会见效。<strong>最糟糕的做法就是假装你们之间的别扭感不重要</strong>，假装工作上的事都是“对事不对人”。这简直是愚蠢无知！事都是人做的啊，情绪必定会影响工作。</p></blockquote><p>低处的果子未必摘得到</p><blockquote><p><strong>当你距离果子越远的时候，它看起来才越低。等你走近一些，你会发现它长得比你想象中高。</strong></p><p>我们想当然地认为它很容易摘，只是因为此前我们从没尝试过。</p><p><strong>请尊重你从没做过的事。提醒自己，他人的工作没有那么简单。</strong></p></blockquote><p>简历不重要</p><blockquote><p>把关注重点放在<strong>候选人的人品和工作能力</strong>上，免得聘用一个想象出来的虚像。</p><p>渴望干出漂亮活儿的优秀人才常常来自你最预料不到的地方，而且他们看上去跟你想象中的完全不一样。<strong>你只需把重点放在他们的人品和工作能力上，这是唯一能找到他们的方法。</strong></p></blockquote><p>不必理会人才争夺战</p><blockquote><p>人才是不值得争夺的，它不是一种数量有限的稀缺资源——你要么拥有，要么就失去。</p><p>我们发现，<strong>培养人才、发掘他们未被开发的潜力，远比找到一个已经处于巅峰的人刺激得多</strong>。</p><p>当年我们雇用这些最出色的员工，并不是因为他们那时的模样，而是因为他们日后会长成的样子。</p></blockquote><p>不做薪酬谈判</p><blockquote><p>在Basecamp，我们不再做工资或加薪谈判。只要级别相同、角色相同，就拿一样的薪水，同工同酬。</p><p>我们的目标是，<strong>无论什么岗位，要让公司里的每一个人拿到的薪水都能位列市场的前10%。</strong></p><p>一定的离职率是好事，但工资不该成为绝大多数人离开的主要原因。</p><p><strong>与军心稳定的团队一起工作，幸福感会源源不断地涌现，公司也会持续高产。</strong></p></blockquote><p>图书馆守则</p><blockquote><p>用图书馆守则作为办公室的行为准则，你只需要做几个简单的设置，改变思维方式，<strong>尊重他人的时间、注意力和专心致志的工作时段</strong>，这就足够了。</p></blockquote><p>拒绝假“度假”</p><blockquote><p>度假的全部目的就是离开。</p><p><strong>雇主没有权力侵占任何人的夜晚、周末或假期，那是人家的生活时间。</strong>真正的危机事件可以例外，但那种事一年最多只能有一两次。</p></blockquote><h4 id="剖析工作流程"><a href="#剖析工作流程" class="headerlink" title="剖析工作流程"></a>剖析工作流程</h4><p>逼死人的截止日期</p><blockquote><p>大多数截止日期简直能逼死人。项目需求不断膨胀，工作越堆越多，可那个不现实的日期却岿然不动。这不叫工作，这是遭罪啊。</p><p>项目可以灵活缩减，这一点极为重要。<strong>这是因为几乎所有需要花6个月完成的事情，其实都能换个形式，在6周之内完成。</strong> 关键就在于<strong>你要知道哪些可以砍掉，何时该叫停，何时该向前走</strong>。</p><p>界限即自由。</p></blockquote><p>新常态</p><blockquote><p>起先，它看上去有点不顺眼。比如某个行为你并不喜欢，但容忍了。然后，某个人也这样做了，但你没注意或没去管。接下来，人们开始接二连三地这样做，因为没人出来阻止。</p><p>此时已经太晚了，它已经变成一种文化，一种新常态。</p><p><strong>如果你不希望组织文化里野草蔓生，那就要小心它的种子。</strong></p></blockquote><p>坏习惯会打败好意愿</p><blockquote><p>积习难改.</p><p>你必须不断自问：你今天的工作状态，是你今后10年、20年、30年想持续下去的吗？如果不是，现在就做出改变，不要等“以后”。</p><p>良好的意愿活不到“以后”。</p></blockquote><p>承诺比共识更重要</p><blockquote><p><strong>在企业中，唯一可持续的办法就是必须有人最后拍板。</strong></p><p>管事的人必须做出最终决断，即便其他人更喜欢另一个方案。</p><p><strong>好决策需要的不是共识，而是承诺。</strong></p><p>在践行“我不同意，但我会配合你”的原则时，尤为重要的是，公司需要把最后的决策向参与的每一个人解释清楚。只有“决策—执行”是不够的，应该是“决策—解释—执行”。</p></blockquote><p>完成比完美更重要</p><blockquote><p>你没法在每件事情上都力争完美。<strong>知道何时该接纳“足够好”，你才有机会在关键时刻来临之时绽放出真正的光彩。</strong></p><p>与其把无限精力投入每个细节，我们会<strong>花大量精力甄选</strong>：哪些是真正重要的事，哪些还算重要，哪些一点儿都不重要。<strong>甄选环节最需要高质量地完成。</strong></p></blockquote><p>逐渐聚焦</p><blockquote><p>工作中时不时会有激动人心的新想法冒出来, 要抗拒它们的诱惑简直是不可能的。可是，<strong>如果你真想往前走，就必须学会聚焦。</strong>[我真的是容易分心啊]</p><p>6周一个项目原则.  头一两周用来澄清未知，验证假设。在这个阶段，概念碰触到了现实，如果它合理，就会站得住脚，如果不合理，就会碎裂掉。</p><p>一旦最初的探索期过去，<strong>每一周都应该离“完成”的目标更近一步，而不是更远一点。</strong>下定决心把任务完成，一点点把想法实现，之后你肯定有机会折返的——但前提是你得真的把这事做完。</p></blockquote><p>“无为”又何妨？</p><blockquote><p>有时候，你必须挑战一些显而易见的道理。有时候，你必须明白，投入了时间未必一定会带来收益。“无为”可能是最艰难的选择，但同时也是最强有力的选择。</p></blockquote><p>最糟实践</p><blockquote><p>每个成熟的行业里都充斥着铺天盖地的“最佳实践”。</p><p>然而，这里头有太多不仅仅是扯淡，而且还很可能是你能做的最糟的事。</p><p>找到最适合自己的方法，做下去就行了。创造属于自己的经验和行为模式，至于这些做法对别人来说算不算最佳实践？管它呢。</p></blockquote><p>多一事不如少一事</p><blockquote><p>想要完成更多事？唯一的办法就是<strong>少干点</strong>。</p><p><strong>说“不”是收回时间的唯一方式。</strong></p><p>别给自己排上12件任务，然后把它们的次序摆弄来摆弄去，企图找到一个效率最高的排列组合；你也用不着设定计时器，闹铃一响就赶紧换下一件事做。把12件事删掉7件，你就有时间做余下的5件了。这不叫时间管理，这叫任务精简。其他的一切秘诀都是忽悠人的。</p><p>最徒劳的莫过于高效地做完全没必要做的事。</p></blockquote><p>魔力数字3</p><blockquote><p>Basecamp的几乎所有产品都是由3个人组成的团队完成的。</p><p>我们不会投入更多人手来解决问题，而是<strong>把问题精简到能被3人小组承担并完成的程度</strong>。</p><p>3令你诚实。它用正确的方式笼住你的野心。它会要求你权衡、折中。最为重要的是，3能减少沟通中的误会，增进协作效率。</p></blockquote><p>“不”的价值</p><blockquote><p>知道自己该对什么说“不”，胜过知道该对什么说“是”。你要明白“不”的价值。</p></blockquote><h4 id="深入思考业务"><a href="#深入思考业务" class="headerlink" title="深入思考业务"></a>深入思考业务</h4><p>冒险不等于鲁莽</p><blockquote><p>冒险不等于鲁莽，<strong>你并不会因为把自己或公司置于毫无必要的险境而变得更加勇敢。</strong>聪明的赌局是，万一局面跟你设想的不一样，你还可以翻盘重玩一遍。</p></blockquote><p>季节轮转</p><blockquote><p>你用相同的方式、相同的步调，做着相同的事情，时间一长，<strong>单调的感觉就会反噬</strong>。[要学会体察自己的感受, 学会保护自己不被单调反噬]</p><p><strong>用工作时长、任务难度，甚至专门的福利来强调季节更替的感觉吧</strong>，想些办法来打破一成不变的单调感受。</p></blockquote><p>利润才是硬道理</p><blockquote><p>我们一直有意识地控制着发展的步伐，不要一下迈得太大。</p><p>我们一直严密关注着成本，并且绝对不做可能会导致公司出现赤字的事情。</p><p>利润意味着你有思考的时间，有探索的空间。它意味着你可以掌控自己的命运和时间表。</p></blockquote><p>故意放弃 [这个真的很独特]</p><blockquote><p><strong>不敢失去的客户是最糟的客户。</strong></p><p>今天，Basecamp软件的价格是每月99美元，一视同仁。[牛逼啊, 极少有公司敢这么做]</p><p>按人数收费的问题在于，它会把你最大的客户变成最好的客户。<strong>如果你没有全然的控制力，金钱就会产生影响</strong>。而这也决定了你要把时间花在谁身上。一旦金钱流动起来，你不可能避开这些压力，<strong>唯一的办法就是把水龙头关上。</strong></p><p>成为一家冷静的公司，关键就在于想清楚你是谁、你想服务谁、你想对谁说“不”，并由此做出决策。</p></blockquote><p>发布，然后学习</p><blockquote><p>如果你想知道自己的产品究竟怎样，那你就得把它发布出去。</p><p>尽你的最大努力去做，相信你的作品，然后发布出去，你就能得到实实在在的答案了。</p><p>真实的市场，那里是你唯一能寻获真相的地方。</p><p>你会从真正需要你的产品的真实用户那里，得到真实的看法与答案，并以此为基础做迭代、改进，发布，然后学习。</p></blockquote><p>别做承诺</p><blockquote><p>从Basecamp初创时起，我们就很不愿意做出产品改进的承诺。<strong>我们向来希望客户能根据现在买到的正在使用的版本来判断产品的好坏</strong>，而不是某个“有可能会”在日后推出的、想象出来的版本。</p><p>承诺就像债务一样，会堆积起来，还会产生利息。</p></blockquote><p>掌控变化</p><blockquote><p>人们不喜欢的是被迫改变——在一个并非由他们主动选择的时间点上，发生了他们并未主动要求的改变。</p><p>当一个新产品突然被甩到他们面前时，你眼中的“全新升级版”，在他们看来很可能变成“什么破玩意儿”。[哈哈]</p><p>我们花了很长时间，绕了很多弯路，才领悟到这个关于销售的核心真理：<strong>把新产品卖给新客户，让老客户留着他们原有的东西</strong>。这就是保持安宁和冷静的方法。</p><p>履行原有的约定，维持老产品运转，这些不是没有成本的。但这就是拥有光辉历史的代价，这就是成功的代价——你取得了相当大的成功，以至于客户在你做出最新的产品之前就已经喜欢你了。</p></blockquote><p>创业容易守业难</p><blockquote><p>越往前走，越艰难，最容易的就是第一天。这就是关于创业的暗黑小秘密。</p><p>如果你明白未来可能是什么样子的，你就能在头脑中演练，在风雨袭来之前做足准备。关键就是你设下了什么样的期望。[自证预言吗?]</p></blockquote><p>美好的旧时光</p><blockquote><p>如果“美好的旧时光”那么美好，我们就尽最大努力留在那个阶段，维持一个可持续的、可管理的规模。我们依然会增长，但要缓慢，并且可以掌控。我们要留在美好的时光里——而且不需要那个“旧”字。</p><p><strong>在顺境中收窄</strong>，这是一家冷静的、赢利的独立公司的奢侈。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《重来3》中文版部分内容摘选.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://lupeipei.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://lupeipei.github.io/tags/Reading/"/>
    
  </entry>
  
</feed>
